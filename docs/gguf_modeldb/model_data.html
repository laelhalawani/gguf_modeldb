<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gguf_modeldb.model_data API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gguf_modeldb.model_data</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import time
import requests
from typing import Union, Optional

from util_helper.file_handler import *

__all__ = [&#39;ModelData&#39;]
&#34;&#34;&#34;
Models data format:
{
    &#34;url&#34;: &#34;https://huggingface.co/TheBloke/Mistral-7B-Instruct-v0.1-GGUF/blob/main/mistral-7b-instruct-v0.1.Q2_K.gguf&#34;,
    &#34;gguf_file_path&#34;: &#34;./models_db/gguf_models\\mistral-7b-instruct-v0.1.Q2_K.gguf&#34;,
    &#34;model_name&#34;: &#34;mistral-7b-instruct-v0.1&#34;,
    &#34;model_quantization&#34;: &#34;Q2_K&#34;,
    &#34;description&#34;: &#34;he Mistral-7B-Instruct-v0.1 Large Language Model (LLM) 
    is a instruct fine-tuned version of the Mistral-7B-v0.1 
    generative text model using a variety of publicly available conversation datasets.&#34;,
    &#34;keywords&#34;: [
        &#34;mistral&#34;,
        &#34;v0.1&#34;,
        &#34;apache&#34;,
        &#34;free&#34;,
        &#34;uncesored&#34;,
        &#34;instruct&#34;
    ],
    &#34;user_tags&#34;: {
        &#34;open&#34;: &#34;[INST]&#34;,
        &#34;close&#34;: &#34;[/INST]&#34;
    },
    &#34;ai_tags&#34;: {
        &#34;open&#34;: &#34;&#34;,
        &#34;close&#34;: &#34;&#34;
    },
    &#34;system_tags&#34;: {
        &#34;open&#34;: null,
        &#34;close&#34;: null
    },
    &#34;save_dir&#34;: &#34;./models_db/gguf_models&#34;
}
&#34;&#34;&#34;


class ModelData:
    &#34;&#34;&#34;Class for storing and managing model data.
    Provides methods for downloading gguf model files, saving metadata to JSON files and loading from JSON files.
    As well as for retreiving model tags and paths.

    Public methods:
        download_gguf(force_redownload:bool=False) -&gt; str: Download gguf model file
        save_json(replace_existing:bool=True) -&gt; str: Save ModelData to JSON file
        from_json(json_file_path:str) -&gt; &#34;ModelData&#34;: Create ModelData from JSON file
        from_url(url:str, save_dir:str, user_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), ai_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), system_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;),
                  description:Optional[str] = None, keywords:Optional[list] = None) -&gt; &#34;ModelData&#34;: Create ModelData from URL
        from_file(gguf_file_path:str, save_dir:Optional[str]=None, user_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), ai_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), system_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;),
                  description:Optional[str] = None, keywords:Optional[list] = None) -&gt; &#34;ModelData&#34;: Create ModelData from gguf file
        model_path() -&gt; str: Get model file path
        get_ai_tag_open() -&gt; str: Get opening AI tag
        get_ai_tag_close() -&gt; str: Get closing AI tag
        get_user_tag_open() -&gt; str: Get opening user tag
        get_user_tag_close() -&gt; str: Get closing user tag
        get_system_tag_open() -&gt; str: Get opening system tag
        get_system_tag_close() -&gt; str: Get closing system tag
        get_ai_tags() -&gt; list[str]: Get list of AI tags
        get_user_tags() -&gt; list[str]: Get list of user tags
        get_system_tags() -&gt; list[str]: Get list of system tags
        has_system_tags() -&gt; bool: Check if system tags are set

    Attributes:
        gguf_url (str): URL of gguf file for model
        gguf_file_path (str): Local file path for downloaded gguf model file
        name (str): Name of the model 
        model_quantization (str): Quantization used for the model
        description (str): Description of the model
        keywords (List[str]): List of keywords for the model
        user_tags (Dict[str, str]): Dictionary of opening and closing tags for user markup
        ai_tags (Dict[str, str]): Dictionary of opening and closing tags for AI markup
        system_tags (Dict[str, str]): Dictionary of opening and closing tags for system markup
        save_dir (str): Directory to save model file and metadata

    &#34;&#34;&#34;
    
    def __init__(self, 
        gguf_url:str,
        db_dir:str,
        user_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), 
        ai_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;),
        system_tags:Optional[Union[dict, list, set]] = None,
        description:Optional[str] = None, 
        keywords:Optional[list] = None,
        ):
        &#34;&#34;&#34;Initialize ModelData object.

        Args:
            gguf_url (str): URL of gguf file for model
            db_dir (str): Directory to save model file and metadata
            user_tags (Union[dict, list, set], optional): User markup tags. Defaults to (&#34;&#34;,&#34;&#34;).
            ai_tags (Union[dict, list, set], optional): AI markup tags. Defaults to (&#34;&#34;,&#34;&#34;).
            system_tags (Optional[Union[dict, list, set]], optional): System markup tags. Defaults to None.
            description (Optional[str], optional): Description of model. Defaults to None.
            keywords (Optional[list], optional): List of keywords. Defaults to None.
        &#34;&#34;&#34;
        
        #init all as None
        self.gguf_url = None
        self.gguf_file_path = None
        self.name = None
        self.model_quantization = None
        self.description = None
        self.keywords = None
        self.user_tags = None
        self.ai_tags = None
        self.system_tags = None
        self.save_dir = None

        #set values
        self.gguf_url = gguf_url
        self.set_save_dir(db_dir)
        self.gguf_file_path = self._url_to_file_path(db_dir, gguf_url) 
        self.name = self._url_extract_model_name(gguf_url)
        self.model_quantization = self._url_extract_quantization(gguf_url)
        self.description = description if description is not None else &#34;&#34;
        self.keywords = keywords if keywords is not None else []
        self.set_tags(ai_tags, user_tags, system_tags)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return string representation of ModelData object.&#34;&#34;&#34;
        
        t = f&#34;&#34;&#34;ModelData(
            ---required---
            gguf_url: {self.gguf_url},
            ---required with defaults--- 
            save_dir: {self.save_dir},
            user_tags: {self.user_tags},
            ai_tags: {self.ai_tags},
            ---optionally provided, no defaults---
            system_tags: {self.system_tags},
            description: {self.description},
            keywords: {self.keywords},
            ---automatically generated---
            gguf_file_path: {self.gguf_file_path},
            model_name: {self.name},
            model_quantization: {self.model_quantization}
        )&#34;&#34;&#34;
        return t
    
    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Return representation of ModelData object.&#34;&#34;&#34;
        return self.__str__()
    
    def __dict__(self) -&gt; dict:
        &#34;&#34;&#34;Return dictionary representation of ModelData object.&#34;&#34;&#34;
        return self.to_dict()
    
    @staticmethod
    def _hf_url_to_download_url(url) -&gt; str:
        &#34;&#34;&#34;Convert HuggingFace URL to download URL.

        Args:
            url (str): HuggingFace URL 

        Returns:
            str: Download URL
        &#34;&#34;&#34;
        #to download replace blob with resolve and add download=true
        if not &#34;huggingface.co&#34; in url:
            raise ValueError(f&#34;Invalid url: {url}, must be a huggingface.co url, other sources aren&#39;t implemented yet.&#34;)
        url = url.replace(&#34;blob&#34;, &#34;resolve&#34;)
        if url.endswith(&#34;/&#34;):
            url = url[:-1]
        if not url.endswith(&#34;?download=true&#34;):
            url = url + &#34;?download=true&#34;
        return url
    
    @staticmethod    
    def _url_to_file_path(save_dir:str, url:str)-&gt;str:
        &#34;&#34;&#34;Convert URL to local file path.

        Args:
            save_dir (str): Directory to save file
            url (str): URL of file

        Returns:
            str: Local file path
        &#34;&#34;&#34;
        #create_dirs_for(save_dir)
        file_path = join_paths(save_dir, ModelData._url_extract_file_name(url))
        return file_path 
    
    @staticmethod
    def _url_extract_file_name(url:str) -&gt; str:
        &#34;&#34;&#34;Extract file name from URL.
        Args:
            url (str): URL

        Returns:
            str: File name
        &#34;&#34;&#34;
        f_name =  url.split(&#34;/&#34;)[-1]
        if is_file_format(f_name, &#34;.gguf&#34;):
            return f_name
        else:
            raise ValueError(f&#34;File {f_name} is not a gguf file.&#34;)
    
    @staticmethod
    def _url_extract_quantization(url:str) -&gt; str:
        &#34;&#34;&#34;Extract quantization from URL.
        Args:
            url (str): URL

        Returns:
            str: Quantization
        &#34;&#34;&#34;
        quantization = ModelData._url_extract_file_name(url).split(&#34;.&#34;)[-2]
        return quantization
    
    @staticmethod
    def _url_extract_model_name(url:str) -&gt; str:
        &#34;&#34;&#34;Extract model name from URL.
        Args:
            url (str): URL

        Returns:
            str: Model name
        &#34;&#34;&#34;
        model_name = ModelData._url_extract_file_name(url).split(&#34;.&#34;)[0:-2]
        return &#34;.&#34;.join(model_name)

    def set_ai_tags(self, ai_tags:Union[dict, set[str], list[str], tuple[str]]) -&gt; None:
        &#34;&#34;&#34;Set AI markup tags.
        Args:
            ai_tags (Union[dict, set, list, tuple]): AI tags
        &#34;&#34;&#34;
        if isinstance(ai_tags, dict):
            if &#34;open&#34; in ai_tags and &#34;close&#34; in ai_tags:
                self.ai_tags = ai_tags
            else:
                raise ValueError(f&#34;Invalid user tags: {ai_tags}, for dict tags both &#39;open&#39; and &#39;close&#39; keys must be present.&#34;)
        elif isinstance(ai_tags, set) or isinstance(ai_tags, list) or isinstance(ai_tags, tuple):
            self.ai_tags = {
                &#34;open&#34;: ai_tags[0],
                &#34;close&#34;: ai_tags[1]
            }
        else:
            raise TypeError(f&#34;Invalid type for user tags: {type(ai_tags)}, must be dict, set or list.&#34;)
        
    def set_user_tags(self, user_tags:Union[dict, set[str], list[str], tuple[str]]) -&gt; None:
        &#34;&#34;&#34;Set user markup tags.
        Args:
            user_tags (Union[dict, set, list, tuple]): User tags
        &#34;&#34;&#34;
        if isinstance(user_tags, dict):
            if &#34;open&#34; in user_tags and &#34;close&#34; in user_tags:
                self.user_tags = user_tags
            else:
                raise ValueError(f&#34;Invalid user tags: {user_tags}, for dict tags both &#39;open&#39; and &#39;close&#39; keys must be present.&#34;)
        elif isinstance(user_tags, set) or isinstance(user_tags, list) or isinstance(user_tags, tuple):
            self.user_tags = {
                &#34;open&#34;: user_tags[0],
                &#34;close&#34;: user_tags[1]
            }
        else:
            raise TypeError(f&#34;Invalid type for user tags: {type(user_tags)}, must be dict, set or list.&#34;)

    def set_system_tags(self, system_tags:Union[dict, set[str], list[str], tuple[str]]) -&gt; None:
        &#34;&#34;&#34;Set system markup tags.
        Args:
            system_tags (Union[dict, set, list, tuple]): System tags
        &#34;&#34;&#34;
        if isinstance(system_tags, dict):
            if &#34;open&#34; in system_tags and &#34;close&#34; in system_tags:
                self.system_tags = system_tags
            else:
                raise ValueError(f&#34;Invalid system tags: {system_tags}, for dict tags both &#39;open&#39; and &#39;close&#39; keys must be present.&#34;)
        elif isinstance(system_tags, set) or isinstance(system_tags, list) or isinstance(system_tags, tuple):
            self.system_tags = {
                &#34;open&#34;: system_tags[0],
                &#34;close&#34;: system_tags[1]
            }
        else:
            raise TypeError(f&#34;Invalid type for system tags: {type(system_tags)}, must be dict, set or list.&#34;)
            
    def set_tags(self, 
                 ai_tags:Optional[Union[dict, set[str], list[str], tuple[str]]],
                 user_tags:Optional[Union[dict, set[str], list[str], tuple[str]]],
                 system_tags:Optional[Union[dict, set[str], list[str], tuple[str]]],
                 ) -&gt; None:
        &#34;&#34;&#34;Sets any of the provided tags.
        Args:
            ai_tags (Optional[Union[dict, set, list, tuple]]): AI tags
            user_tags (Optional[Union[dict, set, list, tuple]]): User tags
            system_tags (Optional[Union[dict, set, list, tuple]]): System tags
        &#34;&#34;&#34;
        if ai_tags is not None:
            self.set_ai_tags(ai_tags)
        if user_tags is not None:
            self.set_user_tags(user_tags)
        if system_tags is not None:
            self.set_system_tags(system_tags)

    def set_save_dir(self, save_dir:str) -&gt; None:
        &#34;&#34;&#34;Set save directory and update save file path for the model.

        Args:
            save_dir (str): Save directory
        &#34;&#34;&#34;
        self.save_dir = save_dir
        self.gguf_file_path = self._url_to_file_path(save_dir, self.gguf_url)

    def to_dict(self):
        &#34;&#34;&#34;Convert ModelData to dictionary.
            &#34;url&#34;: str,
            &#34;save_dir&#34;: str,
            &#34;user_tags&#34;: Union[dict, list, set],
            &#34;ai_tags&#34;: Union[dict, list, set],
            &#34;description&#34;: str,
            &#34;keywords&#34;: list,
            &#34;system_tags&#34;: Union[dict, list, set]

        Returns:
            dict: Dictionary representation of ModelData
        &#34;&#34;&#34;
        model_data = {
            &#34;url&#34;: self.gguf_url,
            &#34;gguf_file_path&#34;: self.gguf_file_path,
            &#34;model_name&#34;: self.name,
            &#34;model_quantization&#34;: self.model_quantization, 
            &#34;description&#34;: self.description,
            &#34;keywords&#34;: self.keywords,
            &#34;user_tags&#34;: self.user_tags,
            &#34;ai_tags&#34;: self.ai_tags,
            &#34;system_tags&#34;: self.system_tags,
            &#34;save_dir&#34;: self.save_dir,
        }
        return model_data
    
    @staticmethod
    def from_dict(model_data:dict) -&gt; &#34;ModelData&#34;:
        &#34;&#34;&#34;Create ModelData from dictionary.

        Args:
            model_data (dict): Dictionary representation of ModelData
            Needs to contain the following keys:
            &#34;url&#34;: str,
            &#34;save_dir&#34;: str,
            &#34;user_tags&#34;: Union[dict, list, set],
            &#34;ai_tags&#34;: Union[dict, list, set],
            and optionally:
            &#34;description&#34;: str,
            &#34;keywords&#34;: list,
            &#34;system_tags&#34;: Union[dict, list, set]

        Returns:
            ModelData: ModelData object
        &#34;&#34;&#34;
        url = model_data[&#34;url&#34;]
        save_dir = model_data[&#34;save_dir&#34;]
        description = model_data[&#34;description&#34;] if &#34;description&#34; in model_data else None
        keywords = model_data[&#34;keywords&#34;] if &#34;keywords&#34; in model_data else None
        user_tags = model_data[&#34;user_tags&#34;]
        ai_tags = model_data[&#34;ai_tags&#34;]
        system_tags = model_data[&#34;system_tags&#34;] if &#34;system_tags&#34; in model_data else None
        new_model_data = ModelData(url, save_dir, user_tags, ai_tags, system_tags, description, keywords)
        return new_model_data

    def is_downloaded(self) -&gt; bool:
        &#34;&#34;&#34;Check if model file is downloaded.
        
        Returns:
            bool: True if downloaded, False otherwise
        &#34;&#34;&#34;
        return does_file_exist(self.gguf_file_path)
    
    def has_json(self) -&gt; bool:
        &#34;&#34;&#34;Check if JSON metadata file exists.

        Returns:
            bool: True if exists, False otherwise
        &#34;&#34;&#34;
        return does_file_exist(self.json_path())
    
    def download_gguf(self, force_redownload:bool=False) -&gt; str:
        &#34;&#34;&#34;Download gguf model file.

        Args:
            force_redownload (bool, optional): Force redownload if exists. Defaults to False.

        Returns:
            str: File path of downloaded file
        &#34;&#34;&#34;
        print(f&#34;Preparing {self.gguf_file_path}\n for {self.name} : {self.model_quantization}...&#34;)
        if not does_file_exist(self.gguf_file_path) or force_redownload:
            print(f&#34;Downloading {self.name} : {self.model_quantization}...&#34;)
            gguf_download_url = self._hf_url_to_download_url(self.gguf_url)
            response = requests.get(gguf_download_url, stream=True)
            total_size = int(response.headers.get(&#39;content-length&#39;, 0))
            block_size = 1024000  # 100 KB
            progress_bar = f&#34;Please wait, downloading {self.name} : {self.model_quantization}: {{0:0.2f}}% | {{1:0.3f}}/{{2:0.3f}} GB) | {{3:0.3f}} MB/s&#34;
            unfinished_save_path = self.gguf_file_path + &#34;.unfinished&#34;
            with open(unfinished_save_path, &#34;wb&#34;) as f:
                downloaded_size = 0
                start_time = time.time()
                elapsed_time = 0
                downloaded_since_last = 0
                for data in response.iter_content(block_size):
                    downloaded_size += len(data)
                    downloaded_since_last += len(data)
                    f.write(data)
                    elapsed_time = time.time() - start_time
                    download_speed = (downloaded_since_last*10/(1024**3)) / elapsed_time if elapsed_time &gt; 0 else 0
                    progress = downloaded_size / total_size * 100
                    gb_downloaded = downloaded_size/(1024**3)
                    gb_total = total_size/(1024**3)
                    if elapsed_time &gt;= 1:
                        print(progress_bar.format(progress, gb_downloaded, gb_total, download_speed), end=&#39;\r&#39;)
                        downloaded_since_last = 0
                        start_time = time.time()
            print(progress_bar.format(100, gb_downloaded, gb_total, download_speed))
            rename_file(unfinished_save_path, self.gguf_file_path)
        else:
            print(f&#34;File {self.gguf_file_path} already exists. Skipping download.&#34;)
        return self.gguf_file_path
    
    def json_path(self) -&gt; str:
        &#34;&#34;&#34;Get path for JSON metadata file.

        Returns:
            str: JSON file path
        &#34;&#34;&#34;
        return change_extension(self.gguf_file_path, &#34;.json&#34;)
    
    def save_json(self, replace_existing:bool=True) -&gt; str:
        &#34;&#34;&#34;Save ModelData to JSON file.

        Args:
            replace_existing (bool, optional): Overwrite if exists. Defaults to True.

        Returns:
            str: JSON file path
        &#34;&#34;&#34;
        if replace_existing or not self.has_json():
            save_json_file(self.json_path(), self.to_dict())
        else:
            print(f&#34;File {self.json_path()} already exists and replace_existing={replace_existing}. Skipping save.&#34;)
        return self.json_path()
    
    @staticmethod
    def from_json(json_file_path:str) -&gt; &#34;ModelData&#34;:
        &#34;&#34;&#34;Create ModelData from JSON file.

        Args:
            json_file_path (str): Path to JSON file containing model data

        Returns:
            ModelData: ModelData object
        &#34;&#34;&#34;
        model_data = load_json_file(json_file_path)
        return ModelData.from_dict(model_data)


    @staticmethod
    def from_url(url:str, save_dir:str, user_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), ai_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), system_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;),
                  description:Optional[str] = None, keywords:Optional[list] = None) -&gt; &#34;ModelData&#34;:
        &#34;&#34;&#34;Create ModelData from URL.

        Args:
            url (str): gguf URL
            save_dir (str): Directory to save model
            user_tags (Union[dict, list, set], optional): User markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
            ai_tags (Union[dict, list, set], optional): AI markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
            system_tags (Union[dict, list, set], optional): System markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
            description (Optional[str], optional): Model description. Defaults to None.
            keywords (Optional[list], optional): List of keywords. Defaults to None.

        Returns:
            ModelData: ModelData object
        &#34;&#34;&#34;
        return ModelData(url, save_dir, user_tags, ai_tags, system_tags, description, keywords)

    def model_path(self) -&gt; str:
        &#34;&#34;&#34;Get model file path.
        
        Returns:
            str: gguf file path
        &#34;&#34;&#34;
        return self.gguf_file_path

    @staticmethod
    def from_file(gguf_file_path:str, save_dir:Optional[str]=None, user_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), ai_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), system_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;),
                  description:Optional[str] = None, keywords:Optional[list] = None) -&gt; &#34;ModelData&#34;:
        &#34;&#34;&#34;Create ModelData from gguf file.

        Args:
            gguf_file_path (str): Path to gguf file
            save_dir (Optional[str], optional): Directory to save. Defaults to None.
            user_tags (Union[dict, list, set], optional): User markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
            ai_tags (Union[dict, list, set], optional): AI markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
            system_tags (Union[dict, list, set], optional): System markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
            description (Optional[str], optional): Model description. Defaults to None.
            keywords (Optional[list], optional): List of keywords. Defaults to None.

        Returns:
            ModelData: ModelData object
        &#34;&#34;&#34;        
        #creates a model where url is also the file path
        save_dir = get_directory(gguf_file_path) if save_dir is None else save_dir
        url = gguf_file_path
        return ModelData(url, save_dir, user_tags, ai_tags, system_tags, description, keywords)

    def get_ai_tag_open(self) -&gt; str:
        &#34;&#34;&#34;Get opening AI tag.
        
        Returns:
            str: Opening AI tag
        &#34;&#34;&#34;
        return self.ai_tags[&#34;open&#34;]
    
    def get_ai_tag_close(self) -&gt; str:
        &#34;&#34;&#34;Get closing AI tag.
        
        Returns:
            str: Closing AI tag
        &#34;&#34;&#34;
        return self.ai_tags[&#34;close&#34;]
    
    def get_user_tag_open(self) -&gt; str:
        &#34;&#34;&#34;Get opening user tag.
        
        Returns:
            str: Opening user tag
        &#34;&#34;&#34;
        return self.user_tags[&#34;open&#34;]
    
    def get_user_tag_close(self) -&gt; str:
        &#34;&#34;&#34;Get closing user tag.
        
        Returns:
            str: Closing user tag
        &#34;&#34;&#34;
        return self.user_tags[&#34;close&#34;]
    
    def get_system_tag_open(self) -&gt; str:
        &#34;&#34;&#34;Get opening system tag.
        
        Returns:
            str: Opening system tag
        &#34;&#34;&#34;
        return self.system_tags[&#34;open&#34;]
    
    def get_system_tag_close(self) -&gt; str:
        &#34;&#34;&#34;Get closing system tag.
        
        Returns:
            str: Closing system tag
        &#34;&#34;&#34;
        return self.system_tags[&#34;close&#34;]
    
    def get_ai_tags(self) -&gt; list[str]:
        &#34;&#34;&#34;Get list of AI tags.
        
        Returns:
            list[str]: List of opening and closing AI tags
        &#34;&#34;&#34;
        return [self.get_ai_tag_open(), self.get_ai_tag_close()]
    
    def get_user_tags(self) -&gt; list[str]:
        &#34;&#34;&#34;Get list of user tags.
        
        Returns:
            list[str]: List of opening and closing user tags
        &#34;&#34;&#34;
        return [self.get_user_tag_open(), self.get_user_tag_close()]
    
    def get_system_tags(self) -&gt; list[str]:
        &#34;&#34;&#34;Get list of system tags.
        
        Returns:
            list[str]: List of opening and closing system tags
        &#34;&#34;&#34;
        return [self.get_system_tag_open(), self.get_system_tag_close()]
    
    def has_system_tags(self) -&gt; bool:
        &#34;&#34;&#34;Check if system tags are set.
        
        Returns:
            bool: True if system tags set, False otherwise
        &#34;&#34;&#34;
        if self.system_tags is None:
            return False
        elif self.system_tags[&#34;open&#34;] is None or self.system_tags[&#34;close&#34;] is None:
            return False
        else:
            return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gguf_modeldb.model_data.ModelData"><code class="flex name class">
<span>class <span class="ident">ModelData</span></span>
<span>(</span><span>gguf_url: str, db_dir: str, user_tags: Union[dict, list, set] = ('', ''), ai_tags: Union[dict, list, set] = ('', ''), system_tags: Union[dict, list, set, ForwardRef(None)] = None, description: Optional[str] = None, keywords: Optional[None] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for storing and managing model data.
Provides methods for downloading gguf model files, saving metadata to JSON files and loading from JSON files.
As well as for retreiving model tags and paths.</p>
<p>Public methods:
download_gguf(force_redownload:bool=False) -&gt; str: Download gguf model file
save_json(replace_existing:bool=True) -&gt; str: Save ModelData to JSON file
from_json(json_file_path:str) -&gt; "ModelData": Create ModelData from JSON file
from_url(url:str, save_dir:str, user_tags:Union[dict, list, set] = ("", ""), ai_tags:Union[dict, list, set] = ("", ""), system_tags:Union[dict, list, set] = ("", ""),
description:Optional[str] = None, keywords:Optional[list] = None) -&gt; "ModelData": Create ModelData from URL
from_file(gguf_file_path:str, save_dir:Optional[str]=None, user_tags:Union[dict, list, set] = ("", ""), ai_tags:Union[dict, list, set] = ("", ""), system_tags:Union[dict, list, set] = ("", ""),
description:Optional[str] = None, keywords:Optional[list] = None) -&gt; "ModelData": Create ModelData from gguf file
model_path() -&gt; str: Get model file path
get_ai_tag_open() -&gt; str: Get opening AI tag
get_ai_tag_close() -&gt; str: Get closing AI tag
get_user_tag_open() -&gt; str: Get opening user tag
get_user_tag_close() -&gt; str: Get closing user tag
get_system_tag_open() -&gt; str: Get opening system tag
get_system_tag_close() -&gt; str: Get closing system tag
get_ai_tags() -&gt; list[str]: Get list of AI tags
get_user_tags() -&gt; list[str]: Get list of user tags
get_system_tags() -&gt; list[str]: Get list of system tags
has_system_tags() -&gt; bool: Check if system tags are set</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>gguf_url</code></strong> :&ensp;<code>str</code></dt>
<dd>URL of gguf file for model</dd>
<dt><strong><code>gguf_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Local file path for downloaded gguf model file</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the model </dd>
<dt><strong><code>model_quantization</code></strong> :&ensp;<code>str</code></dt>
<dd>Quantization used for the model</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>Description of the model</dd>
<dt><strong><code>keywords</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of keywords for the model</dd>
<dt><strong><code>user_tags</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>Dictionary of opening and closing tags for user markup</dd>
<dt><strong><code>ai_tags</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>Dictionary of opening and closing tags for AI markup</dd>
<dt><strong><code>system_tags</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>Dictionary of opening and closing tags for system markup</dd>
<dt><strong><code>save_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>Directory to save model file and metadata</dd>
</dl>
<p>Initialize ModelData object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gguf_url</code></strong> :&ensp;<code>str</code></dt>
<dd>URL of gguf file for model</dd>
<dt><strong><code>db_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>Directory to save model file and metadata</dd>
<dt><strong><code>user_tags</code></strong> :&ensp;<code>Union[dict, list, set]</code>, optional</dt>
<dd>User markup tags. Defaults to ("","").</dd>
<dt><strong><code>ai_tags</code></strong> :&ensp;<code>Union[dict, list, set]</code>, optional</dt>
<dd>AI markup tags. Defaults to ("","").</dd>
<dt><strong><code>system_tags</code></strong> :&ensp;<code>Optional[Union[dict, list, set]]</code>, optional</dt>
<dd>System markup tags. Defaults to None.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>Description of model. Defaults to None.</dd>
<dt><strong><code>keywords</code></strong> :&ensp;<code>Optional[list]</code>, optional</dt>
<dd>List of keywords. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelData:
    &#34;&#34;&#34;Class for storing and managing model data.
    Provides methods for downloading gguf model files, saving metadata to JSON files and loading from JSON files.
    As well as for retreiving model tags and paths.

    Public methods:
        download_gguf(force_redownload:bool=False) -&gt; str: Download gguf model file
        save_json(replace_existing:bool=True) -&gt; str: Save ModelData to JSON file
        from_json(json_file_path:str) -&gt; &#34;ModelData&#34;: Create ModelData from JSON file
        from_url(url:str, save_dir:str, user_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), ai_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), system_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;),
                  description:Optional[str] = None, keywords:Optional[list] = None) -&gt; &#34;ModelData&#34;: Create ModelData from URL
        from_file(gguf_file_path:str, save_dir:Optional[str]=None, user_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), ai_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), system_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;),
                  description:Optional[str] = None, keywords:Optional[list] = None) -&gt; &#34;ModelData&#34;: Create ModelData from gguf file
        model_path() -&gt; str: Get model file path
        get_ai_tag_open() -&gt; str: Get opening AI tag
        get_ai_tag_close() -&gt; str: Get closing AI tag
        get_user_tag_open() -&gt; str: Get opening user tag
        get_user_tag_close() -&gt; str: Get closing user tag
        get_system_tag_open() -&gt; str: Get opening system tag
        get_system_tag_close() -&gt; str: Get closing system tag
        get_ai_tags() -&gt; list[str]: Get list of AI tags
        get_user_tags() -&gt; list[str]: Get list of user tags
        get_system_tags() -&gt; list[str]: Get list of system tags
        has_system_tags() -&gt; bool: Check if system tags are set

    Attributes:
        gguf_url (str): URL of gguf file for model
        gguf_file_path (str): Local file path for downloaded gguf model file
        name (str): Name of the model 
        model_quantization (str): Quantization used for the model
        description (str): Description of the model
        keywords (List[str]): List of keywords for the model
        user_tags (Dict[str, str]): Dictionary of opening and closing tags for user markup
        ai_tags (Dict[str, str]): Dictionary of opening and closing tags for AI markup
        system_tags (Dict[str, str]): Dictionary of opening and closing tags for system markup
        save_dir (str): Directory to save model file and metadata

    &#34;&#34;&#34;
    
    def __init__(self, 
        gguf_url:str,
        db_dir:str,
        user_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), 
        ai_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;),
        system_tags:Optional[Union[dict, list, set]] = None,
        description:Optional[str] = None, 
        keywords:Optional[list] = None,
        ):
        &#34;&#34;&#34;Initialize ModelData object.

        Args:
            gguf_url (str): URL of gguf file for model
            db_dir (str): Directory to save model file and metadata
            user_tags (Union[dict, list, set], optional): User markup tags. Defaults to (&#34;&#34;,&#34;&#34;).
            ai_tags (Union[dict, list, set], optional): AI markup tags. Defaults to (&#34;&#34;,&#34;&#34;).
            system_tags (Optional[Union[dict, list, set]], optional): System markup tags. Defaults to None.
            description (Optional[str], optional): Description of model. Defaults to None.
            keywords (Optional[list], optional): List of keywords. Defaults to None.
        &#34;&#34;&#34;
        
        #init all as None
        self.gguf_url = None
        self.gguf_file_path = None
        self.name = None
        self.model_quantization = None
        self.description = None
        self.keywords = None
        self.user_tags = None
        self.ai_tags = None
        self.system_tags = None
        self.save_dir = None

        #set values
        self.gguf_url = gguf_url
        self.set_save_dir(db_dir)
        self.gguf_file_path = self._url_to_file_path(db_dir, gguf_url) 
        self.name = self._url_extract_model_name(gguf_url)
        self.model_quantization = self._url_extract_quantization(gguf_url)
        self.description = description if description is not None else &#34;&#34;
        self.keywords = keywords if keywords is not None else []
        self.set_tags(ai_tags, user_tags, system_tags)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return string representation of ModelData object.&#34;&#34;&#34;
        
        t = f&#34;&#34;&#34;ModelData(
            ---required---
            gguf_url: {self.gguf_url},
            ---required with defaults--- 
            save_dir: {self.save_dir},
            user_tags: {self.user_tags},
            ai_tags: {self.ai_tags},
            ---optionally provided, no defaults---
            system_tags: {self.system_tags},
            description: {self.description},
            keywords: {self.keywords},
            ---automatically generated---
            gguf_file_path: {self.gguf_file_path},
            model_name: {self.name},
            model_quantization: {self.model_quantization}
        )&#34;&#34;&#34;
        return t
    
    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Return representation of ModelData object.&#34;&#34;&#34;
        return self.__str__()
    
    def __dict__(self) -&gt; dict:
        &#34;&#34;&#34;Return dictionary representation of ModelData object.&#34;&#34;&#34;
        return self.to_dict()
    
    @staticmethod
    def _hf_url_to_download_url(url) -&gt; str:
        &#34;&#34;&#34;Convert HuggingFace URL to download URL.

        Args:
            url (str): HuggingFace URL 

        Returns:
            str: Download URL
        &#34;&#34;&#34;
        #to download replace blob with resolve and add download=true
        if not &#34;huggingface.co&#34; in url:
            raise ValueError(f&#34;Invalid url: {url}, must be a huggingface.co url, other sources aren&#39;t implemented yet.&#34;)
        url = url.replace(&#34;blob&#34;, &#34;resolve&#34;)
        if url.endswith(&#34;/&#34;):
            url = url[:-1]
        if not url.endswith(&#34;?download=true&#34;):
            url = url + &#34;?download=true&#34;
        return url
    
    @staticmethod    
    def _url_to_file_path(save_dir:str, url:str)-&gt;str:
        &#34;&#34;&#34;Convert URL to local file path.

        Args:
            save_dir (str): Directory to save file
            url (str): URL of file

        Returns:
            str: Local file path
        &#34;&#34;&#34;
        #create_dirs_for(save_dir)
        file_path = join_paths(save_dir, ModelData._url_extract_file_name(url))
        return file_path 
    
    @staticmethod
    def _url_extract_file_name(url:str) -&gt; str:
        &#34;&#34;&#34;Extract file name from URL.
        Args:
            url (str): URL

        Returns:
            str: File name
        &#34;&#34;&#34;
        f_name =  url.split(&#34;/&#34;)[-1]
        if is_file_format(f_name, &#34;.gguf&#34;):
            return f_name
        else:
            raise ValueError(f&#34;File {f_name} is not a gguf file.&#34;)
    
    @staticmethod
    def _url_extract_quantization(url:str) -&gt; str:
        &#34;&#34;&#34;Extract quantization from URL.
        Args:
            url (str): URL

        Returns:
            str: Quantization
        &#34;&#34;&#34;
        quantization = ModelData._url_extract_file_name(url).split(&#34;.&#34;)[-2]
        return quantization
    
    @staticmethod
    def _url_extract_model_name(url:str) -&gt; str:
        &#34;&#34;&#34;Extract model name from URL.
        Args:
            url (str): URL

        Returns:
            str: Model name
        &#34;&#34;&#34;
        model_name = ModelData._url_extract_file_name(url).split(&#34;.&#34;)[0:-2]
        return &#34;.&#34;.join(model_name)

    def set_ai_tags(self, ai_tags:Union[dict, set[str], list[str], tuple[str]]) -&gt; None:
        &#34;&#34;&#34;Set AI markup tags.
        Args:
            ai_tags (Union[dict, set, list, tuple]): AI tags
        &#34;&#34;&#34;
        if isinstance(ai_tags, dict):
            if &#34;open&#34; in ai_tags and &#34;close&#34; in ai_tags:
                self.ai_tags = ai_tags
            else:
                raise ValueError(f&#34;Invalid user tags: {ai_tags}, for dict tags both &#39;open&#39; and &#39;close&#39; keys must be present.&#34;)
        elif isinstance(ai_tags, set) or isinstance(ai_tags, list) or isinstance(ai_tags, tuple):
            self.ai_tags = {
                &#34;open&#34;: ai_tags[0],
                &#34;close&#34;: ai_tags[1]
            }
        else:
            raise TypeError(f&#34;Invalid type for user tags: {type(ai_tags)}, must be dict, set or list.&#34;)
        
    def set_user_tags(self, user_tags:Union[dict, set[str], list[str], tuple[str]]) -&gt; None:
        &#34;&#34;&#34;Set user markup tags.
        Args:
            user_tags (Union[dict, set, list, tuple]): User tags
        &#34;&#34;&#34;
        if isinstance(user_tags, dict):
            if &#34;open&#34; in user_tags and &#34;close&#34; in user_tags:
                self.user_tags = user_tags
            else:
                raise ValueError(f&#34;Invalid user tags: {user_tags}, for dict tags both &#39;open&#39; and &#39;close&#39; keys must be present.&#34;)
        elif isinstance(user_tags, set) or isinstance(user_tags, list) or isinstance(user_tags, tuple):
            self.user_tags = {
                &#34;open&#34;: user_tags[0],
                &#34;close&#34;: user_tags[1]
            }
        else:
            raise TypeError(f&#34;Invalid type for user tags: {type(user_tags)}, must be dict, set or list.&#34;)

    def set_system_tags(self, system_tags:Union[dict, set[str], list[str], tuple[str]]) -&gt; None:
        &#34;&#34;&#34;Set system markup tags.
        Args:
            system_tags (Union[dict, set, list, tuple]): System tags
        &#34;&#34;&#34;
        if isinstance(system_tags, dict):
            if &#34;open&#34; in system_tags and &#34;close&#34; in system_tags:
                self.system_tags = system_tags
            else:
                raise ValueError(f&#34;Invalid system tags: {system_tags}, for dict tags both &#39;open&#39; and &#39;close&#39; keys must be present.&#34;)
        elif isinstance(system_tags, set) or isinstance(system_tags, list) or isinstance(system_tags, tuple):
            self.system_tags = {
                &#34;open&#34;: system_tags[0],
                &#34;close&#34;: system_tags[1]
            }
        else:
            raise TypeError(f&#34;Invalid type for system tags: {type(system_tags)}, must be dict, set or list.&#34;)
            
    def set_tags(self, 
                 ai_tags:Optional[Union[dict, set[str], list[str], tuple[str]]],
                 user_tags:Optional[Union[dict, set[str], list[str], tuple[str]]],
                 system_tags:Optional[Union[dict, set[str], list[str], tuple[str]]],
                 ) -&gt; None:
        &#34;&#34;&#34;Sets any of the provided tags.
        Args:
            ai_tags (Optional[Union[dict, set, list, tuple]]): AI tags
            user_tags (Optional[Union[dict, set, list, tuple]]): User tags
            system_tags (Optional[Union[dict, set, list, tuple]]): System tags
        &#34;&#34;&#34;
        if ai_tags is not None:
            self.set_ai_tags(ai_tags)
        if user_tags is not None:
            self.set_user_tags(user_tags)
        if system_tags is not None:
            self.set_system_tags(system_tags)

    def set_save_dir(self, save_dir:str) -&gt; None:
        &#34;&#34;&#34;Set save directory and update save file path for the model.

        Args:
            save_dir (str): Save directory
        &#34;&#34;&#34;
        self.save_dir = save_dir
        self.gguf_file_path = self._url_to_file_path(save_dir, self.gguf_url)

    def to_dict(self):
        &#34;&#34;&#34;Convert ModelData to dictionary.
            &#34;url&#34;: str,
            &#34;save_dir&#34;: str,
            &#34;user_tags&#34;: Union[dict, list, set],
            &#34;ai_tags&#34;: Union[dict, list, set],
            &#34;description&#34;: str,
            &#34;keywords&#34;: list,
            &#34;system_tags&#34;: Union[dict, list, set]

        Returns:
            dict: Dictionary representation of ModelData
        &#34;&#34;&#34;
        model_data = {
            &#34;url&#34;: self.gguf_url,
            &#34;gguf_file_path&#34;: self.gguf_file_path,
            &#34;model_name&#34;: self.name,
            &#34;model_quantization&#34;: self.model_quantization, 
            &#34;description&#34;: self.description,
            &#34;keywords&#34;: self.keywords,
            &#34;user_tags&#34;: self.user_tags,
            &#34;ai_tags&#34;: self.ai_tags,
            &#34;system_tags&#34;: self.system_tags,
            &#34;save_dir&#34;: self.save_dir,
        }
        return model_data
    
    @staticmethod
    def from_dict(model_data:dict) -&gt; &#34;ModelData&#34;:
        &#34;&#34;&#34;Create ModelData from dictionary.

        Args:
            model_data (dict): Dictionary representation of ModelData
            Needs to contain the following keys:
            &#34;url&#34;: str,
            &#34;save_dir&#34;: str,
            &#34;user_tags&#34;: Union[dict, list, set],
            &#34;ai_tags&#34;: Union[dict, list, set],
            and optionally:
            &#34;description&#34;: str,
            &#34;keywords&#34;: list,
            &#34;system_tags&#34;: Union[dict, list, set]

        Returns:
            ModelData: ModelData object
        &#34;&#34;&#34;
        url = model_data[&#34;url&#34;]
        save_dir = model_data[&#34;save_dir&#34;]
        description = model_data[&#34;description&#34;] if &#34;description&#34; in model_data else None
        keywords = model_data[&#34;keywords&#34;] if &#34;keywords&#34; in model_data else None
        user_tags = model_data[&#34;user_tags&#34;]
        ai_tags = model_data[&#34;ai_tags&#34;]
        system_tags = model_data[&#34;system_tags&#34;] if &#34;system_tags&#34; in model_data else None
        new_model_data = ModelData(url, save_dir, user_tags, ai_tags, system_tags, description, keywords)
        return new_model_data

    def is_downloaded(self) -&gt; bool:
        &#34;&#34;&#34;Check if model file is downloaded.
        
        Returns:
            bool: True if downloaded, False otherwise
        &#34;&#34;&#34;
        return does_file_exist(self.gguf_file_path)
    
    def has_json(self) -&gt; bool:
        &#34;&#34;&#34;Check if JSON metadata file exists.

        Returns:
            bool: True if exists, False otherwise
        &#34;&#34;&#34;
        return does_file_exist(self.json_path())
    
    def download_gguf(self, force_redownload:bool=False) -&gt; str:
        &#34;&#34;&#34;Download gguf model file.

        Args:
            force_redownload (bool, optional): Force redownload if exists. Defaults to False.

        Returns:
            str: File path of downloaded file
        &#34;&#34;&#34;
        print(f&#34;Preparing {self.gguf_file_path}\n for {self.name} : {self.model_quantization}...&#34;)
        if not does_file_exist(self.gguf_file_path) or force_redownload:
            print(f&#34;Downloading {self.name} : {self.model_quantization}...&#34;)
            gguf_download_url = self._hf_url_to_download_url(self.gguf_url)
            response = requests.get(gguf_download_url, stream=True)
            total_size = int(response.headers.get(&#39;content-length&#39;, 0))
            block_size = 1024000  # 100 KB
            progress_bar = f&#34;Please wait, downloading {self.name} : {self.model_quantization}: {{0:0.2f}}% | {{1:0.3f}}/{{2:0.3f}} GB) | {{3:0.3f}} MB/s&#34;
            unfinished_save_path = self.gguf_file_path + &#34;.unfinished&#34;
            with open(unfinished_save_path, &#34;wb&#34;) as f:
                downloaded_size = 0
                start_time = time.time()
                elapsed_time = 0
                downloaded_since_last = 0
                for data in response.iter_content(block_size):
                    downloaded_size += len(data)
                    downloaded_since_last += len(data)
                    f.write(data)
                    elapsed_time = time.time() - start_time
                    download_speed = (downloaded_since_last*10/(1024**3)) / elapsed_time if elapsed_time &gt; 0 else 0
                    progress = downloaded_size / total_size * 100
                    gb_downloaded = downloaded_size/(1024**3)
                    gb_total = total_size/(1024**3)
                    if elapsed_time &gt;= 1:
                        print(progress_bar.format(progress, gb_downloaded, gb_total, download_speed), end=&#39;\r&#39;)
                        downloaded_since_last = 0
                        start_time = time.time()
            print(progress_bar.format(100, gb_downloaded, gb_total, download_speed))
            rename_file(unfinished_save_path, self.gguf_file_path)
        else:
            print(f&#34;File {self.gguf_file_path} already exists. Skipping download.&#34;)
        return self.gguf_file_path
    
    def json_path(self) -&gt; str:
        &#34;&#34;&#34;Get path for JSON metadata file.

        Returns:
            str: JSON file path
        &#34;&#34;&#34;
        return change_extension(self.gguf_file_path, &#34;.json&#34;)
    
    def save_json(self, replace_existing:bool=True) -&gt; str:
        &#34;&#34;&#34;Save ModelData to JSON file.

        Args:
            replace_existing (bool, optional): Overwrite if exists. Defaults to True.

        Returns:
            str: JSON file path
        &#34;&#34;&#34;
        if replace_existing or not self.has_json():
            save_json_file(self.json_path(), self.to_dict())
        else:
            print(f&#34;File {self.json_path()} already exists and replace_existing={replace_existing}. Skipping save.&#34;)
        return self.json_path()
    
    @staticmethod
    def from_json(json_file_path:str) -&gt; &#34;ModelData&#34;:
        &#34;&#34;&#34;Create ModelData from JSON file.

        Args:
            json_file_path (str): Path to JSON file containing model data

        Returns:
            ModelData: ModelData object
        &#34;&#34;&#34;
        model_data = load_json_file(json_file_path)
        return ModelData.from_dict(model_data)


    @staticmethod
    def from_url(url:str, save_dir:str, user_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), ai_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), system_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;),
                  description:Optional[str] = None, keywords:Optional[list] = None) -&gt; &#34;ModelData&#34;:
        &#34;&#34;&#34;Create ModelData from URL.

        Args:
            url (str): gguf URL
            save_dir (str): Directory to save model
            user_tags (Union[dict, list, set], optional): User markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
            ai_tags (Union[dict, list, set], optional): AI markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
            system_tags (Union[dict, list, set], optional): System markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
            description (Optional[str], optional): Model description. Defaults to None.
            keywords (Optional[list], optional): List of keywords. Defaults to None.

        Returns:
            ModelData: ModelData object
        &#34;&#34;&#34;
        return ModelData(url, save_dir, user_tags, ai_tags, system_tags, description, keywords)

    def model_path(self) -&gt; str:
        &#34;&#34;&#34;Get model file path.
        
        Returns:
            str: gguf file path
        &#34;&#34;&#34;
        return self.gguf_file_path

    @staticmethod
    def from_file(gguf_file_path:str, save_dir:Optional[str]=None, user_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), ai_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), system_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;),
                  description:Optional[str] = None, keywords:Optional[list] = None) -&gt; &#34;ModelData&#34;:
        &#34;&#34;&#34;Create ModelData from gguf file.

        Args:
            gguf_file_path (str): Path to gguf file
            save_dir (Optional[str], optional): Directory to save. Defaults to None.
            user_tags (Union[dict, list, set], optional): User markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
            ai_tags (Union[dict, list, set], optional): AI markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
            system_tags (Union[dict, list, set], optional): System markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
            description (Optional[str], optional): Model description. Defaults to None.
            keywords (Optional[list], optional): List of keywords. Defaults to None.

        Returns:
            ModelData: ModelData object
        &#34;&#34;&#34;        
        #creates a model where url is also the file path
        save_dir = get_directory(gguf_file_path) if save_dir is None else save_dir
        url = gguf_file_path
        return ModelData(url, save_dir, user_tags, ai_tags, system_tags, description, keywords)

    def get_ai_tag_open(self) -&gt; str:
        &#34;&#34;&#34;Get opening AI tag.
        
        Returns:
            str: Opening AI tag
        &#34;&#34;&#34;
        return self.ai_tags[&#34;open&#34;]
    
    def get_ai_tag_close(self) -&gt; str:
        &#34;&#34;&#34;Get closing AI tag.
        
        Returns:
            str: Closing AI tag
        &#34;&#34;&#34;
        return self.ai_tags[&#34;close&#34;]
    
    def get_user_tag_open(self) -&gt; str:
        &#34;&#34;&#34;Get opening user tag.
        
        Returns:
            str: Opening user tag
        &#34;&#34;&#34;
        return self.user_tags[&#34;open&#34;]
    
    def get_user_tag_close(self) -&gt; str:
        &#34;&#34;&#34;Get closing user tag.
        
        Returns:
            str: Closing user tag
        &#34;&#34;&#34;
        return self.user_tags[&#34;close&#34;]
    
    def get_system_tag_open(self) -&gt; str:
        &#34;&#34;&#34;Get opening system tag.
        
        Returns:
            str: Opening system tag
        &#34;&#34;&#34;
        return self.system_tags[&#34;open&#34;]
    
    def get_system_tag_close(self) -&gt; str:
        &#34;&#34;&#34;Get closing system tag.
        
        Returns:
            str: Closing system tag
        &#34;&#34;&#34;
        return self.system_tags[&#34;close&#34;]
    
    def get_ai_tags(self) -&gt; list[str]:
        &#34;&#34;&#34;Get list of AI tags.
        
        Returns:
            list[str]: List of opening and closing AI tags
        &#34;&#34;&#34;
        return [self.get_ai_tag_open(), self.get_ai_tag_close()]
    
    def get_user_tags(self) -&gt; list[str]:
        &#34;&#34;&#34;Get list of user tags.
        
        Returns:
            list[str]: List of opening and closing user tags
        &#34;&#34;&#34;
        return [self.get_user_tag_open(), self.get_user_tag_close()]
    
    def get_system_tags(self) -&gt; list[str]:
        &#34;&#34;&#34;Get list of system tags.
        
        Returns:
            list[str]: List of opening and closing system tags
        &#34;&#34;&#34;
        return [self.get_system_tag_open(), self.get_system_tag_close()]
    
    def has_system_tags(self) -&gt; bool:
        &#34;&#34;&#34;Check if system tags are set.
        
        Returns:
            bool: True if system tags set, False otherwise
        &#34;&#34;&#34;
        if self.system_tags is None:
            return False
        elif self.system_tags[&#34;open&#34;] is None or self.system_tags[&#34;close&#34;] is None:
            return False
        else:
            return True</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gguf_modeldb.model_data.ModelData.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>model_data: dict) ‑> <a title="gguf_modeldb.model_data.ModelData" href="#gguf_modeldb.model_data.ModelData">ModelData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create ModelData from dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary representation of ModelData</dd>
</dl>
<p>Needs to contain the following keys:
"url": str,
"save_dir": str,
"user_tags": Union[dict, list, set],
"ai_tags": Union[dict, list, set],
and optionally:
"description": str,
"keywords": list,
"system_tags": Union[dict, list, set]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gguf_modeldb.model_data.ModelData" href="#gguf_modeldb.model_data.ModelData">ModelData</a></code></dt>
<dd>ModelData object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(model_data:dict) -&gt; &#34;ModelData&#34;:
    &#34;&#34;&#34;Create ModelData from dictionary.

    Args:
        model_data (dict): Dictionary representation of ModelData
        Needs to contain the following keys:
        &#34;url&#34;: str,
        &#34;save_dir&#34;: str,
        &#34;user_tags&#34;: Union[dict, list, set],
        &#34;ai_tags&#34;: Union[dict, list, set],
        and optionally:
        &#34;description&#34;: str,
        &#34;keywords&#34;: list,
        &#34;system_tags&#34;: Union[dict, list, set]

    Returns:
        ModelData: ModelData object
    &#34;&#34;&#34;
    url = model_data[&#34;url&#34;]
    save_dir = model_data[&#34;save_dir&#34;]
    description = model_data[&#34;description&#34;] if &#34;description&#34; in model_data else None
    keywords = model_data[&#34;keywords&#34;] if &#34;keywords&#34; in model_data else None
    user_tags = model_data[&#34;user_tags&#34;]
    ai_tags = model_data[&#34;ai_tags&#34;]
    system_tags = model_data[&#34;system_tags&#34;] if &#34;system_tags&#34; in model_data else None
    new_model_data = ModelData(url, save_dir, user_tags, ai_tags, system_tags, description, keywords)
    return new_model_data</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>gguf_file_path: str, save_dir: Optional[str] = None, user_tags: Union[dict, list, set] = ('', ''), ai_tags: Union[dict, list, set] = ('', ''), system_tags: Union[dict, list, set] = ('', ''), description: Optional[str] = None, keywords: Optional[None] = None) ‑> <a title="gguf_modeldb.model_data.ModelData" href="#gguf_modeldb.model_data.ModelData">ModelData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create ModelData from gguf file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gguf_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to gguf file</dd>
<dt><strong><code>save_dir</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>Directory to save. Defaults to None.</dd>
<dt><strong><code>user_tags</code></strong> :&ensp;<code>Union[dict, list, set]</code>, optional</dt>
<dd>User markup tags. Defaults to ("", "").</dd>
<dt><strong><code>ai_tags</code></strong> :&ensp;<code>Union[dict, list, set]</code>, optional</dt>
<dd>AI markup tags. Defaults to ("", "").</dd>
<dt><strong><code>system_tags</code></strong> :&ensp;<code>Union[dict, list, set]</code>, optional</dt>
<dd>System markup tags. Defaults to ("", "").</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>Model description. Defaults to None.</dd>
<dt><strong><code>keywords</code></strong> :&ensp;<code>Optional[list]</code>, optional</dt>
<dd>List of keywords. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gguf_modeldb.model_data.ModelData" href="#gguf_modeldb.model_data.ModelData">ModelData</a></code></dt>
<dd>ModelData object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_file(gguf_file_path:str, save_dir:Optional[str]=None, user_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), ai_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), system_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;),
              description:Optional[str] = None, keywords:Optional[list] = None) -&gt; &#34;ModelData&#34;:
    &#34;&#34;&#34;Create ModelData from gguf file.

    Args:
        gguf_file_path (str): Path to gguf file
        save_dir (Optional[str], optional): Directory to save. Defaults to None.
        user_tags (Union[dict, list, set], optional): User markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
        ai_tags (Union[dict, list, set], optional): AI markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
        system_tags (Union[dict, list, set], optional): System markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
        description (Optional[str], optional): Model description. Defaults to None.
        keywords (Optional[list], optional): List of keywords. Defaults to None.

    Returns:
        ModelData: ModelData object
    &#34;&#34;&#34;        
    #creates a model where url is also the file path
    save_dir = get_directory(gguf_file_path) if save_dir is None else save_dir
    url = gguf_file_path
    return ModelData(url, save_dir, user_tags, ai_tags, system_tags, description, keywords)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json_file_path: str) ‑> <a title="gguf_modeldb.model_data.ModelData" href="#gguf_modeldb.model_data.ModelData">ModelData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create ModelData from JSON file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>json_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to JSON file containing model data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gguf_modeldb.model_data.ModelData" href="#gguf_modeldb.model_data.ModelData">ModelData</a></code></dt>
<dd>ModelData object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json_file_path:str) -&gt; &#34;ModelData&#34;:
    &#34;&#34;&#34;Create ModelData from JSON file.

    Args:
        json_file_path (str): Path to JSON file containing model data

    Returns:
        ModelData: ModelData object
    &#34;&#34;&#34;
    model_data = load_json_file(json_file_path)
    return ModelData.from_dict(model_data)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.from_url"><code class="name flex">
<span>def <span class="ident">from_url</span></span>(<span>url: str, save_dir: str, user_tags: Union[dict, list, set] = ('', ''), ai_tags: Union[dict, list, set] = ('', ''), system_tags: Union[dict, list, set] = ('', ''), description: Optional[str] = None, keywords: Optional[None] = None) ‑> <a title="gguf_modeldb.model_data.ModelData" href="#gguf_modeldb.model_data.ModelData">ModelData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create ModelData from URL.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>gguf URL</dd>
<dt><strong><code>save_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>Directory to save model</dd>
<dt><strong><code>user_tags</code></strong> :&ensp;<code>Union[dict, list, set]</code>, optional</dt>
<dd>User markup tags. Defaults to ("", "").</dd>
<dt><strong><code>ai_tags</code></strong> :&ensp;<code>Union[dict, list, set]</code>, optional</dt>
<dd>AI markup tags. Defaults to ("", "").</dd>
<dt><strong><code>system_tags</code></strong> :&ensp;<code>Union[dict, list, set]</code>, optional</dt>
<dd>System markup tags. Defaults to ("", "").</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>Model description. Defaults to None.</dd>
<dt><strong><code>keywords</code></strong> :&ensp;<code>Optional[list]</code>, optional</dt>
<dd>List of keywords. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gguf_modeldb.model_data.ModelData" href="#gguf_modeldb.model_data.ModelData">ModelData</a></code></dt>
<dd>ModelData object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_url(url:str, save_dir:str, user_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), ai_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;), system_tags:Union[dict, list, set] = (&#34;&#34;, &#34;&#34;),
              description:Optional[str] = None, keywords:Optional[list] = None) -&gt; &#34;ModelData&#34;:
    &#34;&#34;&#34;Create ModelData from URL.

    Args:
        url (str): gguf URL
        save_dir (str): Directory to save model
        user_tags (Union[dict, list, set], optional): User markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
        ai_tags (Union[dict, list, set], optional): AI markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
        system_tags (Union[dict, list, set], optional): System markup tags. Defaults to (&#34;&#34;, &#34;&#34;).
        description (Optional[str], optional): Model description. Defaults to None.
        keywords (Optional[list], optional): List of keywords. Defaults to None.

    Returns:
        ModelData: ModelData object
    &#34;&#34;&#34;
    return ModelData(url, save_dir, user_tags, ai_tags, system_tags, description, keywords)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gguf_modeldb.model_data.ModelData.download_gguf"><code class="name flex">
<span>def <span class="ident">download_gguf</span></span>(<span>self, force_redownload: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Download gguf model file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>force_redownload</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Force redownload if exists. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>File path of downloaded file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_gguf(self, force_redownload:bool=False) -&gt; str:
    &#34;&#34;&#34;Download gguf model file.

    Args:
        force_redownload (bool, optional): Force redownload if exists. Defaults to False.

    Returns:
        str: File path of downloaded file
    &#34;&#34;&#34;
    print(f&#34;Preparing {self.gguf_file_path}\n for {self.name} : {self.model_quantization}...&#34;)
    if not does_file_exist(self.gguf_file_path) or force_redownload:
        print(f&#34;Downloading {self.name} : {self.model_quantization}...&#34;)
        gguf_download_url = self._hf_url_to_download_url(self.gguf_url)
        response = requests.get(gguf_download_url, stream=True)
        total_size = int(response.headers.get(&#39;content-length&#39;, 0))
        block_size = 1024000  # 100 KB
        progress_bar = f&#34;Please wait, downloading {self.name} : {self.model_quantization}: {{0:0.2f}}% | {{1:0.3f}}/{{2:0.3f}} GB) | {{3:0.3f}} MB/s&#34;
        unfinished_save_path = self.gguf_file_path + &#34;.unfinished&#34;
        with open(unfinished_save_path, &#34;wb&#34;) as f:
            downloaded_size = 0
            start_time = time.time()
            elapsed_time = 0
            downloaded_since_last = 0
            for data in response.iter_content(block_size):
                downloaded_size += len(data)
                downloaded_since_last += len(data)
                f.write(data)
                elapsed_time = time.time() - start_time
                download_speed = (downloaded_since_last*10/(1024**3)) / elapsed_time if elapsed_time &gt; 0 else 0
                progress = downloaded_size / total_size * 100
                gb_downloaded = downloaded_size/(1024**3)
                gb_total = total_size/(1024**3)
                if elapsed_time &gt;= 1:
                    print(progress_bar.format(progress, gb_downloaded, gb_total, download_speed), end=&#39;\r&#39;)
                    downloaded_since_last = 0
                    start_time = time.time()
        print(progress_bar.format(100, gb_downloaded, gb_total, download_speed))
        rename_file(unfinished_save_path, self.gguf_file_path)
    else:
        print(f&#34;File {self.gguf_file_path} already exists. Skipping download.&#34;)
    return self.gguf_file_path</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.get_ai_tag_close"><code class="name flex">
<span>def <span class="ident">get_ai_tag_close</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get closing AI tag.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Closing AI tag</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ai_tag_close(self) -&gt; str:
    &#34;&#34;&#34;Get closing AI tag.
    
    Returns:
        str: Closing AI tag
    &#34;&#34;&#34;
    return self.ai_tags[&#34;close&#34;]</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.get_ai_tag_open"><code class="name flex">
<span>def <span class="ident">get_ai_tag_open</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get opening AI tag.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Opening AI tag</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ai_tag_open(self) -&gt; str:
    &#34;&#34;&#34;Get opening AI tag.
    
    Returns:
        str: Opening AI tag
    &#34;&#34;&#34;
    return self.ai_tags[&#34;open&#34;]</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.get_ai_tags"><code class="name flex">
<span>def <span class="ident">get_ai_tags</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get list of AI tags.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>List of opening and closing AI tags</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ai_tags(self) -&gt; list[str]:
    &#34;&#34;&#34;Get list of AI tags.
    
    Returns:
        list[str]: List of opening and closing AI tags
    &#34;&#34;&#34;
    return [self.get_ai_tag_open(), self.get_ai_tag_close()]</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.get_system_tag_close"><code class="name flex">
<span>def <span class="ident">get_system_tag_close</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get closing system tag.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Closing system tag</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_tag_close(self) -&gt; str:
    &#34;&#34;&#34;Get closing system tag.
    
    Returns:
        str: Closing system tag
    &#34;&#34;&#34;
    return self.system_tags[&#34;close&#34;]</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.get_system_tag_open"><code class="name flex">
<span>def <span class="ident">get_system_tag_open</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get opening system tag.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Opening system tag</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_tag_open(self) -&gt; str:
    &#34;&#34;&#34;Get opening system tag.
    
    Returns:
        str: Opening system tag
    &#34;&#34;&#34;
    return self.system_tags[&#34;open&#34;]</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.get_system_tags"><code class="name flex">
<span>def <span class="ident">get_system_tags</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get list of system tags.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>List of opening and closing system tags</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_tags(self) -&gt; list[str]:
    &#34;&#34;&#34;Get list of system tags.
    
    Returns:
        list[str]: List of opening and closing system tags
    &#34;&#34;&#34;
    return [self.get_system_tag_open(), self.get_system_tag_close()]</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.get_user_tag_close"><code class="name flex">
<span>def <span class="ident">get_user_tag_close</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get closing user tag.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Closing user tag</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_tag_close(self) -&gt; str:
    &#34;&#34;&#34;Get closing user tag.
    
    Returns:
        str: Closing user tag
    &#34;&#34;&#34;
    return self.user_tags[&#34;close&#34;]</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.get_user_tag_open"><code class="name flex">
<span>def <span class="ident">get_user_tag_open</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get opening user tag.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Opening user tag</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_tag_open(self) -&gt; str:
    &#34;&#34;&#34;Get opening user tag.
    
    Returns:
        str: Opening user tag
    &#34;&#34;&#34;
    return self.user_tags[&#34;open&#34;]</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.get_user_tags"><code class="name flex">
<span>def <span class="ident">get_user_tags</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get list of user tags.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>List of opening and closing user tags</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_tags(self) -&gt; list[str]:
    &#34;&#34;&#34;Get list of user tags.
    
    Returns:
        list[str]: List of opening and closing user tags
    &#34;&#34;&#34;
    return [self.get_user_tag_open(), self.get_user_tag_close()]</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.has_json"><code class="name flex">
<span>def <span class="ident">has_json</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if JSON metadata file exists.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if exists, False otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_json(self) -&gt; bool:
    &#34;&#34;&#34;Check if JSON metadata file exists.

    Returns:
        bool: True if exists, False otherwise
    &#34;&#34;&#34;
    return does_file_exist(self.json_path())</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.has_system_tags"><code class="name flex">
<span>def <span class="ident">has_system_tags</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if system tags are set.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if system tags set, False otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_system_tags(self) -&gt; bool:
    &#34;&#34;&#34;Check if system tags are set.
    
    Returns:
        bool: True if system tags set, False otherwise
    &#34;&#34;&#34;
    if self.system_tags is None:
        return False
    elif self.system_tags[&#34;open&#34;] is None or self.system_tags[&#34;close&#34;] is None:
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.is_downloaded"><code class="name flex">
<span>def <span class="ident">is_downloaded</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if model file is downloaded.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if downloaded, False otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_downloaded(self) -&gt; bool:
    &#34;&#34;&#34;Check if model file is downloaded.
    
    Returns:
        bool: True if downloaded, False otherwise
    &#34;&#34;&#34;
    return does_file_exist(self.gguf_file_path)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.json_path"><code class="name flex">
<span>def <span class="ident">json_path</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get path for JSON metadata file.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>JSON file path</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_path(self) -&gt; str:
    &#34;&#34;&#34;Get path for JSON metadata file.

    Returns:
        str: JSON file path
    &#34;&#34;&#34;
    return change_extension(self.gguf_file_path, &#34;.json&#34;)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.model_path"><code class="name flex">
<span>def <span class="ident">model_path</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get model file path.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>gguf file path</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_path(self) -&gt; str:
    &#34;&#34;&#34;Get model file path.
    
    Returns:
        str: gguf file path
    &#34;&#34;&#34;
    return self.gguf_file_path</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.save_json"><code class="name flex">
<span>def <span class="ident">save_json</span></span>(<span>self, replace_existing: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Save ModelData to JSON file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>replace_existing</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Overwrite if exists. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>JSON file path</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_json(self, replace_existing:bool=True) -&gt; str:
    &#34;&#34;&#34;Save ModelData to JSON file.

    Args:
        replace_existing (bool, optional): Overwrite if exists. Defaults to True.

    Returns:
        str: JSON file path
    &#34;&#34;&#34;
    if replace_existing or not self.has_json():
        save_json_file(self.json_path(), self.to_dict())
    else:
        print(f&#34;File {self.json_path()} already exists and replace_existing={replace_existing}. Skipping save.&#34;)
    return self.json_path()</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.set_ai_tags"><code class="name flex">
<span>def <span class="ident">set_ai_tags</span></span>(<span>self, ai_tags: Union[dict, set[str], list[str], tuple[str]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set AI markup tags.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ai_tags</code></strong> :&ensp;<code>Union[dict, set, list, tuple]</code></dt>
<dd>AI tags</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_ai_tags(self, ai_tags:Union[dict, set[str], list[str], tuple[str]]) -&gt; None:
    &#34;&#34;&#34;Set AI markup tags.
    Args:
        ai_tags (Union[dict, set, list, tuple]): AI tags
    &#34;&#34;&#34;
    if isinstance(ai_tags, dict):
        if &#34;open&#34; in ai_tags and &#34;close&#34; in ai_tags:
            self.ai_tags = ai_tags
        else:
            raise ValueError(f&#34;Invalid user tags: {ai_tags}, for dict tags both &#39;open&#39; and &#39;close&#39; keys must be present.&#34;)
    elif isinstance(ai_tags, set) or isinstance(ai_tags, list) or isinstance(ai_tags, tuple):
        self.ai_tags = {
            &#34;open&#34;: ai_tags[0],
            &#34;close&#34;: ai_tags[1]
        }
    else:
        raise TypeError(f&#34;Invalid type for user tags: {type(ai_tags)}, must be dict, set or list.&#34;)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.set_save_dir"><code class="name flex">
<span>def <span class="ident">set_save_dir</span></span>(<span>self, save_dir: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set save directory and update save file path for the model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>Save directory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_save_dir(self, save_dir:str) -&gt; None:
    &#34;&#34;&#34;Set save directory and update save file path for the model.

    Args:
        save_dir (str): Save directory
    &#34;&#34;&#34;
    self.save_dir = save_dir
    self.gguf_file_path = self._url_to_file_path(save_dir, self.gguf_url)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.set_system_tags"><code class="name flex">
<span>def <span class="ident">set_system_tags</span></span>(<span>self, system_tags: Union[dict, set[str], list[str], tuple[str]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set system markup tags.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>system_tags</code></strong> :&ensp;<code>Union[dict, set, list, tuple]</code></dt>
<dd>System tags</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_system_tags(self, system_tags:Union[dict, set[str], list[str], tuple[str]]) -&gt; None:
    &#34;&#34;&#34;Set system markup tags.
    Args:
        system_tags (Union[dict, set, list, tuple]): System tags
    &#34;&#34;&#34;
    if isinstance(system_tags, dict):
        if &#34;open&#34; in system_tags and &#34;close&#34; in system_tags:
            self.system_tags = system_tags
        else:
            raise ValueError(f&#34;Invalid system tags: {system_tags}, for dict tags both &#39;open&#39; and &#39;close&#39; keys must be present.&#34;)
    elif isinstance(system_tags, set) or isinstance(system_tags, list) or isinstance(system_tags, tuple):
        self.system_tags = {
            &#34;open&#34;: system_tags[0],
            &#34;close&#34;: system_tags[1]
        }
    else:
        raise TypeError(f&#34;Invalid type for system tags: {type(system_tags)}, must be dict, set or list.&#34;)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.set_tags"><code class="name flex">
<span>def <span class="ident">set_tags</span></span>(<span>self, ai_tags: Union[dict, set[str], list[str], tuple[str], ForwardRef(None)], user_tags: Union[dict, set[str], list[str], tuple[str], ForwardRef(None)], system_tags: Union[dict, set[str], list[str], tuple[str], ForwardRef(None)]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets any of the provided tags.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ai_tags</code></strong> :&ensp;<code>Optional[Union[dict, set, list, tuple]]</code></dt>
<dd>AI tags</dd>
<dt><strong><code>user_tags</code></strong> :&ensp;<code>Optional[Union[dict, set, list, tuple]]</code></dt>
<dd>User tags</dd>
<dt><strong><code>system_tags</code></strong> :&ensp;<code>Optional[Union[dict, set, list, tuple]]</code></dt>
<dd>System tags</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tags(self, 
             ai_tags:Optional[Union[dict, set[str], list[str], tuple[str]]],
             user_tags:Optional[Union[dict, set[str], list[str], tuple[str]]],
             system_tags:Optional[Union[dict, set[str], list[str], tuple[str]]],
             ) -&gt; None:
    &#34;&#34;&#34;Sets any of the provided tags.
    Args:
        ai_tags (Optional[Union[dict, set, list, tuple]]): AI tags
        user_tags (Optional[Union[dict, set, list, tuple]]): User tags
        system_tags (Optional[Union[dict, set, list, tuple]]): System tags
    &#34;&#34;&#34;
    if ai_tags is not None:
        self.set_ai_tags(ai_tags)
    if user_tags is not None:
        self.set_user_tags(user_tags)
    if system_tags is not None:
        self.set_system_tags(system_tags)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.set_user_tags"><code class="name flex">
<span>def <span class="ident">set_user_tags</span></span>(<span>self, user_tags: Union[dict, set[str], list[str], tuple[str]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set user markup tags.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_tags</code></strong> :&ensp;<code>Union[dict, set, list, tuple]</code></dt>
<dd>User tags</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_user_tags(self, user_tags:Union[dict, set[str], list[str], tuple[str]]) -&gt; None:
    &#34;&#34;&#34;Set user markup tags.
    Args:
        user_tags (Union[dict, set, list, tuple]): User tags
    &#34;&#34;&#34;
    if isinstance(user_tags, dict):
        if &#34;open&#34; in user_tags and &#34;close&#34; in user_tags:
            self.user_tags = user_tags
        else:
            raise ValueError(f&#34;Invalid user tags: {user_tags}, for dict tags both &#39;open&#39; and &#39;close&#39; keys must be present.&#34;)
    elif isinstance(user_tags, set) or isinstance(user_tags, list) or isinstance(user_tags, tuple):
        self.user_tags = {
            &#34;open&#34;: user_tags[0],
            &#34;close&#34;: user_tags[1]
        }
    else:
        raise TypeError(f&#34;Invalid type for user tags: {type(user_tags)}, must be dict, set or list.&#34;)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.model_data.ModelData.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert ModelData to dictionary.
"url": str,
"save_dir": str,
"user_tags": Union[dict, list, set],
"ai_tags": Union[dict, list, set],
"description": str,
"keywords": list,
"system_tags": Union[dict, list, set]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary representation of ModelData</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    &#34;&#34;&#34;Convert ModelData to dictionary.
        &#34;url&#34;: str,
        &#34;save_dir&#34;: str,
        &#34;user_tags&#34;: Union[dict, list, set],
        &#34;ai_tags&#34;: Union[dict, list, set],
        &#34;description&#34;: str,
        &#34;keywords&#34;: list,
        &#34;system_tags&#34;: Union[dict, list, set]

    Returns:
        dict: Dictionary representation of ModelData
    &#34;&#34;&#34;
    model_data = {
        &#34;url&#34;: self.gguf_url,
        &#34;gguf_file_path&#34;: self.gguf_file_path,
        &#34;model_name&#34;: self.name,
        &#34;model_quantization&#34;: self.model_quantization, 
        &#34;description&#34;: self.description,
        &#34;keywords&#34;: self.keywords,
        &#34;user_tags&#34;: self.user_tags,
        &#34;ai_tags&#34;: self.ai_tags,
        &#34;system_tags&#34;: self.system_tags,
        &#34;save_dir&#34;: self.save_dir,
    }
    return model_data</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gguf_modeldb" href="index.html">gguf_modeldb</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gguf_modeldb.model_data.ModelData" href="#gguf_modeldb.model_data.ModelData">ModelData</a></code></h4>
<ul class="">
<li><code><a title="gguf_modeldb.model_data.ModelData.download_gguf" href="#gguf_modeldb.model_data.ModelData.download_gguf">download_gguf</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.from_dict" href="#gguf_modeldb.model_data.ModelData.from_dict">from_dict</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.from_file" href="#gguf_modeldb.model_data.ModelData.from_file">from_file</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.from_json" href="#gguf_modeldb.model_data.ModelData.from_json">from_json</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.from_url" href="#gguf_modeldb.model_data.ModelData.from_url">from_url</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.get_ai_tag_close" href="#gguf_modeldb.model_data.ModelData.get_ai_tag_close">get_ai_tag_close</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.get_ai_tag_open" href="#gguf_modeldb.model_data.ModelData.get_ai_tag_open">get_ai_tag_open</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.get_ai_tags" href="#gguf_modeldb.model_data.ModelData.get_ai_tags">get_ai_tags</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.get_system_tag_close" href="#gguf_modeldb.model_data.ModelData.get_system_tag_close">get_system_tag_close</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.get_system_tag_open" href="#gguf_modeldb.model_data.ModelData.get_system_tag_open">get_system_tag_open</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.get_system_tags" href="#gguf_modeldb.model_data.ModelData.get_system_tags">get_system_tags</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.get_user_tag_close" href="#gguf_modeldb.model_data.ModelData.get_user_tag_close">get_user_tag_close</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.get_user_tag_open" href="#gguf_modeldb.model_data.ModelData.get_user_tag_open">get_user_tag_open</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.get_user_tags" href="#gguf_modeldb.model_data.ModelData.get_user_tags">get_user_tags</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.has_json" href="#gguf_modeldb.model_data.ModelData.has_json">has_json</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.has_system_tags" href="#gguf_modeldb.model_data.ModelData.has_system_tags">has_system_tags</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.is_downloaded" href="#gguf_modeldb.model_data.ModelData.is_downloaded">is_downloaded</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.json_path" href="#gguf_modeldb.model_data.ModelData.json_path">json_path</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.model_path" href="#gguf_modeldb.model_data.ModelData.model_path">model_path</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.save_json" href="#gguf_modeldb.model_data.ModelData.save_json">save_json</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.set_ai_tags" href="#gguf_modeldb.model_data.ModelData.set_ai_tags">set_ai_tags</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.set_save_dir" href="#gguf_modeldb.model_data.ModelData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.set_system_tags" href="#gguf_modeldb.model_data.ModelData.set_system_tags">set_system_tags</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.set_tags" href="#gguf_modeldb.model_data.ModelData.set_tags">set_tags</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.set_user_tags" href="#gguf_modeldb.model_data.ModelData.set_user_tags">set_user_tags</a></code></li>
<li><code><a title="gguf_modeldb.model_data.ModelData.to_dict" href="#gguf_modeldb.model_data.ModelData.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>