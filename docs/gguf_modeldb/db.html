<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gguf_modeldb.db API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gguf_modeldb.db</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import bs4
import requests
from typing import Union, Optional

from util_helper.file_handler import create_dir, list_files_in_dir, copy_large_file, get_absolute_path
from util_helper.compare_strings import compare_two_strings
from .model_data import ModelData
from .db_settings import VERIFIED_MODELS_DB_DIR

class ModelDB:
    &#34;&#34;&#34;Class for managing a database of ModelData objects.

    Handles loading models from a directory, searching, adding new models,
    and interfacing with HuggingFace to import models.

    Attributes:
        gguf_db_dir (str): Path to directory containing ModelData files
        models (List[ModelData]): List of ModelData objects  
    &#34;&#34;&#34;
    
    def __init__(self, model_db_dir:Optional[str]=None, copy_verified_models=True):
        &#34;&#34;&#34;Initialize ModelDB object.

        Args:
            model_db_dir (str, optional): Path to database directory. Defaults to VERIFIED_MODELS_DB_DIR.
            copy_verified_models (bool, optional): Whether to copy example models to the new directory. Defaults to True.
        &#34;&#34;&#34;
        self.gguf_db_dir = None
        self.models = []

        if model_db_dir is None:
            model_db_dir = VERIFIED_MODELS_DB_DIR
        else:
            model_db_dir = get_absolute_path(model_db_dir)
        self.set_model_db_dir(model_db_dir)


        if model_db_dir != VERIFIED_MODELS_DB_DIR:
            if copy_verified_models:
                print(f&#34;Copying examples to {model_db_dir}...&#34;)
                for file in list_files_in_dir(VERIFIED_MODELS_DB_DIR, False, True, [&#34;.json&#34;], absolute=True):
                    f_mdt = ModelData.from_json(file)
                    f_mdt.set_save_dir(model_db_dir)
                    f_mdt.save_json()
                    print(f&#34;Saved a copy of {file} to {model_db_dir}.&#34;)
        else:
            print(f&#34;Using default model db dir: {model_db_dir}, reconfiguring models...&#34;)
            for file in list_files_in_dir(VERIFIED_MODELS_DB_DIR, False, True, [&#34;.json&#34;], absolute=True):
                f_mdt = ModelData.from_json(file)
                f_mdt.set_save_dir(model_db_dir)
                f_mdt.save_json()
                print(f&#34;Reconfigured {file}.&#34;)

        self.load_models()
    
    def set_model_db_dir(self, model_db_dir:str) -&gt; None:
        &#34;&#34;&#34;Set the database directory.

        Args:
            model_db_dir (str): Path to database directory
        &#34;&#34;&#34;
        print(f&#34;ModelDB dir set to {model_db_dir}.&#34;)
        self.gguf_db_dir = create_dir(model_db_dir)
    
    def load_models(self) -&gt; None:
        &#34;&#34;&#34;Load ModelData objects from the database directory.&#34;&#34;&#34;
        self.models = []
        files = list_files_in_dir(self.gguf_db_dir, False, True, [&#34;.json&#34;], absolute=True)
        for file in files:
            try:
                model_data = ModelData.from_json(file)
                self.models.append(model_data)
            except Exception as e:
                print(f&#34;Error trying to load from {file}: \t\n{e}, \nskipping...&#34;)
                continue
        print(f&#34;Loaded {len(self.models)} models from {self.gguf_db_dir}.&#34;)

    def find_models(self, name_query:Optional[str]=None, 
                   quantization_query:Optional[str]=None, 
                   keywords_query:Optional[str]=None,
                   treshold:float=0.6) -&gt; Union[None, list]:
        &#34;&#34;&#34;Search for models based on name, quantization, and keywords.

        Args:
            name_query (str, optional): Search query for name
            quantization_query (str, optional): Search query for quantization 
            keywords_query (str, optional): Search query for keywords
            treshold (float, optional): Minimum score threshold. Defaults to 0.6.

        Returns:
            Union[None, list]: Sorted list of models exceeding threshold,
                               or None if no query provided
        &#34;&#34;&#34;
        if name_query is None and quantization_query is None and keywords_query is None:
            return None
        scoring_models_dict = {}
        for i, model in enumerate(self.models):
            scoring_models_dict[i] = {&#34;model&#34;:model, &#34;score&#34;:0}
        for id in scoring_models_dict.keys():
            model = scoring_models_dict[id][&#34;model&#34;]
            model:ModelData = model
            model_name = model.name
            model_quantization = model.model_quantization
            model_keywords = model.keywords
            if name_query is not None:
                #print(f&#34;Searching for name: {name_query}&#34;)
                top_name_score = 0
                for model_subname in model_name.split(&#34;-&#34;):
                    name_score = compare_two_strings(name_query, model_subname)
                    if name_score &gt; top_name_score:
                        top_name_score = name_score
                if top_name_score &gt; treshold:
                    scoring_models_dict[id][&#34;score&#34;] += top_name_score*4
                #print(f&#34;Model {model_name} {model_quantization} top score: {top_name_score} treshold: {treshold}&#34;)
            if quantization_query is not None:
                #print(f&#34;Searching for quantization: {quantization_query}&#34;)
                quantization_score = compare_two_strings(quantization_query, model_quantization)
                if quantization_score &gt; treshold:
                    scoring_models_dict[id][&#34;score&#34;] += quantization_score*2
                #print(f&#34;Model {model_name} {model_quantization} score: {quantization_score} treshold: {treshold}&#34;)
            if keywords_query is not None:
                #print(f&#34;Searching for keyword: {keywords_query}&#34;)
                best_keyword_score = 0
                for keyword in model_keywords:
                    keyword_score = compare_two_strings(keywords_query, keyword)
                    if keyword_score &gt; best_keyword_score:
                        best_keyword_score = keyword_score
                if best_keyword_score &gt; treshold:
                    scoring_models_dict[id][&#34;score&#34;] += best_keyword_score
                #print(f&#34;Model {model_name} {model_quantization} score: {best_keyword_score} treshold: {treshold}&#34;)
            #print(f&#34;Model {model_name} {model_quantization} score: {scoring_models_dict[id][&#39;score&#39;]}&#34;)
        sorted_models = sorted(scoring_models_dict.items(), key=lambda x: x[1][&#34;score&#34;], reverse=True)
        #keep just the list of model data
        sorted_models = [x[1][&#34;model&#34;] for x in sorted_models]
        #print(f&#34;Found {len(sorted_models)} models.&#34;)
        #print(sorted_models)
        return sorted_models
    
    def find_model(self, name_query:Optional[str]=None, 
                   quantization_query:Optional[str]=None, 
                   keywords_query:Optional[str]=None,
                   ) -&gt; Optional[ModelData]:
        &#34;&#34;&#34;Find top matching model based on queries.

        Args:
            name_query (str, optional): Search query for name
            quantization_query (str, optional): Search query for quantization
            keywords_query (str, optional): Search query for keywords

        Returns:
            Optional[ModelData]: Top matching ModelData object or None
        &#34;&#34;&#34;
        sorted_models = self.find_models(name_query, quantization_query, keywords_query)
        if sorted_models is None or len(sorted_models) == 0:
            if len(self.models) == 0:
                print(f&#34;There were no models to be searched. Try importing a verified model or using the defualt db dir.&#34;)
            raise Exception(f&#34;Could not find a model matching the query: {name_query} {quantization_query} {keywords_query}&#34;)
        else:
            #print(f&#34;Found {len(sorted_models)} models.&#34;)
            #print(sorted_models)
            return sorted_models[0]
        
    def get_model_by_url(self, url:str) -&gt; Optional[ModelData]:
        &#34;&#34;&#34;Get ModelData by exact URL match.

        Args:
            url (str): ggUF URL

        Returns:
            Optional[ModelData]: Matching ModelData or None if not found
        &#34;&#34;&#34;
        for model in self.models:
            model:ModelData = model
            if model.gguf_url == url:
                return model
        return None
        
    def add_model_data(self, model_data:ModelData, save_model=True) -&gt; None:
        &#34;&#34;&#34;Add a ModelData object to the database.

        Args:
            model_data (ModelData): ModelData object to add
            save_model (bool, optional): Whether to save ModelData to file. Defaults to True.
        &#34;&#34;&#34;
        self.models.append(model_data)
        if save_model:
            model_data.save_json()
    
    def add_model_by_url(self, url:str, ) -&gt; None:
        &#34;&#34;&#34;Add a model by URL.

        Args:
            url (str): ggUF URL
        &#34;&#34;&#34;
        model_data = ModelData(url, db_dir=self.gguf_db_dir)
        self.add_model_data(model_data)

    def add_model_by_json(self, json_file_path:str) -&gt; None:
        &#34;&#34;&#34;Add a model from a JSON file.

        Args:
            json_file_path (str): Path to ModelData JSON file
        &#34;&#34;&#34;
        model_data = ModelData.from_json(json_file_path)
        self.add_model_data(model_data)

    def save_all_models(self) -&gt; None:
        &#34;&#34;&#34;Save all ModelData objects to file.&#34;&#34;&#34;
        for model in self.models:
            model:ModelData = model
            model.save_json()
                
    @staticmethod
    def _model_links_from_repo(hf_repo_url:str):
        &#34;&#34;&#34;Extract ggUF model links from a HuggingFace repo page.

        Args:
            hf_repo_url (str): URL of HuggingFace model repo

        Returns:
            list: List of ggUF URLs
        &#34;&#34;&#34;
        #extract models from hf 
        response = requests.get(hf_repo_url)
        html = response.text
        soup = bs4.BeautifulSoup(html, &#39;html.parser&#39;)
        #find all links that end with .gguf
        print(f&#34;Looking for {hf_repo_url} gguf files...&#34;)
        model_links = []
        for link in soup.find_all(&#39;a&#39;):
            href = link.get(&#39;href&#39;)
            if href is not None and href.endswith(&#34;.gguf&#34;):
                print(f&#34;Found model: {href}&#34;)
                model_links.append(href)
        return model_links
    
    def load_models_data_from_repo(self, hf_repo_url:str, 
                        user_tags:Optional[list[str]]=None,
                        ai_tags:Optional[list[str]]=None,
                        system_tags:Optional[list[str]]=None,
                        keywords:Optional[list[str]]=None, 
                        description:Optional[str]=None):
        &#34;&#34;&#34;Load model data from a HuggingFace repo page.

        Args:
            hf_repo_url (str): URL of HuggingFace model repo
            user_tags (Optional[list[str]], optional): User tags to apply. Defaults to None.
            ai_tags (Optional[list[str]], optional): AI tags to apply. Defaults to None.
            system_tags (Optional[list[str]], optional): System tags to apply. Defaults to None.
            keywords (Optional[list[str]], optional): Keywords to apply. Defaults to None.
            description (Optional[str], optional): Description to apply. Defaults to None.

        Returns:
            list: List of loaded ModelData objects
        &#34;&#34;&#34;
        #create model data from hf repo
        model_links = ModelDB._model_links_from_repo(hf_repo_url)
        model_datas = []
        for model_link in model_links:
            model_data = ModelData(gguf_url=model_link, db_dir=self.gguf_db_dir, user_tags=user_tags, ai_tags=ai_tags, system_tags=system_tags, description=description, keywords=keywords)
            model_datas.append(model_data)
            model_data.save_json()
        self.models.extend(model_datas)
        return model_datas

    def import_models_from_repo(self, hf_repo_url:str,
                        user_tags:Optional[list[str]]=None,
                        ai_tags:Optional[list[str]]=None,
                        system_tags:Optional[list[str]]=None,
                        keywords:Optional[list[str]]=None, 
                        description:Optional[str]=None,
                        replace_existing:bool=False,
                        ):
        &#34;&#34;&#34;Import models from a HuggingFace repo page.

        Args:
            hf_repo_url (str): URL of HuggingFace model repo  
            user_tags (Optional[list[str]], optional): User tags to apply. Defaults to None.
            ai_tags (Optional[list[str]], optional): AI tags to apply. Defaults to None.
            system_tags (Optional[list[str]], optional): System tags to apply. Defaults to None.
            keywords (Optional[list[str]], optional): Keywords to apply. Defaults to None.
            description (Optional[str], optional): Description to apply. Defaults to None.
            replace_existing (bool, optional): Whether to overwrite existing files. Defaults to False.
        &#34;&#34;&#34;
        #create model data from hf repo
        model_links = ModelDB._model_links_from_repo(hf_repo_url)
        print(f&#34;Loaded {len(model_links)} models from {hf_repo_url}.&#34;)
        for model_link in model_links:
            model_data = ModelData(gguf_url=model_link, db_dir=self.gguf_db_dir, user_tags=user_tags, ai_tags=ai_tags, system_tags=system_tags, description=description, keywords=keywords)
            model_data.save_json(replace_existing=replace_existing)
        self.load_models()
    

    def import_verified_model(self, 
                              name_search:Optional[str]=None,
                              quantization_search:Optional[str]=None,
                              keywords_search:Optional[str]=None,
                              copy_gguf:bool=True) -&gt; None:
        &#34;&#34;&#34;Import a verified model from the verified model database with ready configurations into your selected db dir.
        Use this to selectively add models from the verified model database to your own database.
        Models inlcude official dolphin, mistral, mixtral, solar and zephyr models in all available quantizations. 
        Args:
            name_search (Optional[str], optional): Search query for name. Defaults to None.
            quantization_search (Optional[str], optional): Search query for quantization. Defaults to None.
            keywords_search (Optional[str], optional): Search query for keywords. Defaults to None.
        &#34;&#34;&#34;
        if self.gguf_db_dir == VERIFIED_MODELS_DB_DIR:
            print(&#34;Cannot import verified model to the default database directory. All models should be already available here.&#34;)
        else:
            vmdb = ModelDB()
            model = vmdb.find_model(name_search, quantization_search, keywords_search)
            if copy_gguf and model.is_downloaded():
                source_file = model.gguf_file_path
                target_file = model.gguf_file_path.replace(vmdb.gguf_db_dir, self.gguf_db_dir)
                print(f&#34;Copying {source_file} to {target_file}...&#34;)
                copy_large_file(source_file, target_file)

            model.set_save_dir(self.gguf_db_dir)
            model.save_json()
            self.load_models()

    def list_available_models(self) -&gt; list[str]:
        &#34;&#34;&#34;Get a list of available model names.

        Returns:
            list[str]: List of model names
        &#34;&#34;&#34;
        print(f&#34;Available models in {self.gguf_db_dir}:&#34;)
        models = []
        for model in self.models:
            model:ModelData = model
            if model.name not in models:
                models.append(model.name)
        return models
    
    def list_models_quantizations(self, model_name:str) -&gt; list[str]:
        &#34;&#34;&#34;Get list of quantizations for a model.

        Args:
            model_name (str): Name of model

        Returns:
            list[str]: List of quantizations
        &#34;&#34;&#34;
        quantizations = []
        for model in self.models:
            model:ModelData = model
            if model.name == model_name:
                quantizations.append(model.model_quantization)
        return quantizations

    def show_db_info(self) -&gt; None:
        &#34;&#34;&#34;Print summary information about the database.&#34;&#34;&#34;
        print(f&#34;ModelDB summary:&#34;)
        print(f&#34;ModelDB dir: {self.gguf_db_dir}&#34;)
        print(f&#34;Number of models: {len(self.models)}&#34;)
        print(f&#34;Available models:&#34;)
        models_info = {}
        for model in self.models:
            model:ModelData = model
            if model.name not in models_info.keys():
                models_info[model.name] = {}
                models_info[model.name][&#34;quantizations&#34;] = []
                models_info[model.name][&#34;description&#34;] = model.description
                models_info[model.name][&#34;keywords&#34;] = model.keywords
            if model.model_quantization not in models_info[model.name][&#34;quantizations&#34;]:
                models_info[model.name][&#34;quantizations&#34;].append(model.model_quantization)
        
        for model_name, models_info in models_info.items():
            print(f&#34;\t{model_name}:&#34;)
            print(f&#34;\t\tQuantizations: {models_info[&#39;quantizations&#39;]}&#34;)
            print(f&#34;\t\tKeywords: {models_info[&#39;keywords&#39;]}&#34;)
            print(f&#34;\t\tDescription: {models_info[&#39;description&#39;]}&#34;)
            print(f&#34;\t-------------------------------&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gguf_modeldb.db.ModelDB"><code class="flex name class">
<span>class <span class="ident">ModelDB</span></span>
<span>(</span><span>model_db_dir: Optional[str] = None, copy_verified_models=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for managing a database of ModelData objects.</p>
<p>Handles loading models from a directory, searching, adding new models,
and interfacing with HuggingFace to import models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>gguf_db_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to directory containing ModelData files</dd>
<dt><strong><code>models</code></strong> :&ensp;<code>List[ModelData]</code></dt>
<dd>List of ModelData objects
</dd>
</dl>
<p>Initialize ModelDB object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_db_dir</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path to database directory. Defaults to VERIFIED_MODELS_DB_DIR.</dd>
<dt><strong><code>copy_verified_models</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to copy example models to the new directory. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelDB:
    &#34;&#34;&#34;Class for managing a database of ModelData objects.

    Handles loading models from a directory, searching, adding new models,
    and interfacing with HuggingFace to import models.

    Attributes:
        gguf_db_dir (str): Path to directory containing ModelData files
        models (List[ModelData]): List of ModelData objects  
    &#34;&#34;&#34;
    
    def __init__(self, model_db_dir:Optional[str]=None, copy_verified_models=True):
        &#34;&#34;&#34;Initialize ModelDB object.

        Args:
            model_db_dir (str, optional): Path to database directory. Defaults to VERIFIED_MODELS_DB_DIR.
            copy_verified_models (bool, optional): Whether to copy example models to the new directory. Defaults to True.
        &#34;&#34;&#34;
        self.gguf_db_dir = None
        self.models = []

        if model_db_dir is None:
            model_db_dir = VERIFIED_MODELS_DB_DIR
        else:
            model_db_dir = get_absolute_path(model_db_dir)
        self.set_model_db_dir(model_db_dir)


        if model_db_dir != VERIFIED_MODELS_DB_DIR:
            if copy_verified_models:
                print(f&#34;Copying examples to {model_db_dir}...&#34;)
                for file in list_files_in_dir(VERIFIED_MODELS_DB_DIR, False, True, [&#34;.json&#34;], absolute=True):
                    f_mdt = ModelData.from_json(file)
                    f_mdt.set_save_dir(model_db_dir)
                    f_mdt.save_json()
                    print(f&#34;Saved a copy of {file} to {model_db_dir}.&#34;)
        else:
            print(f&#34;Using default model db dir: {model_db_dir}, reconfiguring models...&#34;)
            for file in list_files_in_dir(VERIFIED_MODELS_DB_DIR, False, True, [&#34;.json&#34;], absolute=True):
                f_mdt = ModelData.from_json(file)
                f_mdt.set_save_dir(model_db_dir)
                f_mdt.save_json()
                print(f&#34;Reconfigured {file}.&#34;)

        self.load_models()
    
    def set_model_db_dir(self, model_db_dir:str) -&gt; None:
        &#34;&#34;&#34;Set the database directory.

        Args:
            model_db_dir (str): Path to database directory
        &#34;&#34;&#34;
        print(f&#34;ModelDB dir set to {model_db_dir}.&#34;)
        self.gguf_db_dir = create_dir(model_db_dir)
    
    def load_models(self) -&gt; None:
        &#34;&#34;&#34;Load ModelData objects from the database directory.&#34;&#34;&#34;
        self.models = []
        files = list_files_in_dir(self.gguf_db_dir, False, True, [&#34;.json&#34;], absolute=True)
        for file in files:
            try:
                model_data = ModelData.from_json(file)
                self.models.append(model_data)
            except Exception as e:
                print(f&#34;Error trying to load from {file}: \t\n{e}, \nskipping...&#34;)
                continue
        print(f&#34;Loaded {len(self.models)} models from {self.gguf_db_dir}.&#34;)

    def find_models(self, name_query:Optional[str]=None, 
                   quantization_query:Optional[str]=None, 
                   keywords_query:Optional[str]=None,
                   treshold:float=0.6) -&gt; Union[None, list]:
        &#34;&#34;&#34;Search for models based on name, quantization, and keywords.

        Args:
            name_query (str, optional): Search query for name
            quantization_query (str, optional): Search query for quantization 
            keywords_query (str, optional): Search query for keywords
            treshold (float, optional): Minimum score threshold. Defaults to 0.6.

        Returns:
            Union[None, list]: Sorted list of models exceeding threshold,
                               or None if no query provided
        &#34;&#34;&#34;
        if name_query is None and quantization_query is None and keywords_query is None:
            return None
        scoring_models_dict = {}
        for i, model in enumerate(self.models):
            scoring_models_dict[i] = {&#34;model&#34;:model, &#34;score&#34;:0}
        for id in scoring_models_dict.keys():
            model = scoring_models_dict[id][&#34;model&#34;]
            model:ModelData = model
            model_name = model.name
            model_quantization = model.model_quantization
            model_keywords = model.keywords
            if name_query is not None:
                #print(f&#34;Searching for name: {name_query}&#34;)
                top_name_score = 0
                for model_subname in model_name.split(&#34;-&#34;):
                    name_score = compare_two_strings(name_query, model_subname)
                    if name_score &gt; top_name_score:
                        top_name_score = name_score
                if top_name_score &gt; treshold:
                    scoring_models_dict[id][&#34;score&#34;] += top_name_score*4
                #print(f&#34;Model {model_name} {model_quantization} top score: {top_name_score} treshold: {treshold}&#34;)
            if quantization_query is not None:
                #print(f&#34;Searching for quantization: {quantization_query}&#34;)
                quantization_score = compare_two_strings(quantization_query, model_quantization)
                if quantization_score &gt; treshold:
                    scoring_models_dict[id][&#34;score&#34;] += quantization_score*2
                #print(f&#34;Model {model_name} {model_quantization} score: {quantization_score} treshold: {treshold}&#34;)
            if keywords_query is not None:
                #print(f&#34;Searching for keyword: {keywords_query}&#34;)
                best_keyword_score = 0
                for keyword in model_keywords:
                    keyword_score = compare_two_strings(keywords_query, keyword)
                    if keyword_score &gt; best_keyword_score:
                        best_keyword_score = keyword_score
                if best_keyword_score &gt; treshold:
                    scoring_models_dict[id][&#34;score&#34;] += best_keyword_score
                #print(f&#34;Model {model_name} {model_quantization} score: {best_keyword_score} treshold: {treshold}&#34;)
            #print(f&#34;Model {model_name} {model_quantization} score: {scoring_models_dict[id][&#39;score&#39;]}&#34;)
        sorted_models = sorted(scoring_models_dict.items(), key=lambda x: x[1][&#34;score&#34;], reverse=True)
        #keep just the list of model data
        sorted_models = [x[1][&#34;model&#34;] for x in sorted_models]
        #print(f&#34;Found {len(sorted_models)} models.&#34;)
        #print(sorted_models)
        return sorted_models
    
    def find_model(self, name_query:Optional[str]=None, 
                   quantization_query:Optional[str]=None, 
                   keywords_query:Optional[str]=None,
                   ) -&gt; Optional[ModelData]:
        &#34;&#34;&#34;Find top matching model based on queries.

        Args:
            name_query (str, optional): Search query for name
            quantization_query (str, optional): Search query for quantization
            keywords_query (str, optional): Search query for keywords

        Returns:
            Optional[ModelData]: Top matching ModelData object or None
        &#34;&#34;&#34;
        sorted_models = self.find_models(name_query, quantization_query, keywords_query)
        if sorted_models is None or len(sorted_models) == 0:
            if len(self.models) == 0:
                print(f&#34;There were no models to be searched. Try importing a verified model or using the defualt db dir.&#34;)
            raise Exception(f&#34;Could not find a model matching the query: {name_query} {quantization_query} {keywords_query}&#34;)
        else:
            #print(f&#34;Found {len(sorted_models)} models.&#34;)
            #print(sorted_models)
            return sorted_models[0]
        
    def get_model_by_url(self, url:str) -&gt; Optional[ModelData]:
        &#34;&#34;&#34;Get ModelData by exact URL match.

        Args:
            url (str): ggUF URL

        Returns:
            Optional[ModelData]: Matching ModelData or None if not found
        &#34;&#34;&#34;
        for model in self.models:
            model:ModelData = model
            if model.gguf_url == url:
                return model
        return None
        
    def add_model_data(self, model_data:ModelData, save_model=True) -&gt; None:
        &#34;&#34;&#34;Add a ModelData object to the database.

        Args:
            model_data (ModelData): ModelData object to add
            save_model (bool, optional): Whether to save ModelData to file. Defaults to True.
        &#34;&#34;&#34;
        self.models.append(model_data)
        if save_model:
            model_data.save_json()
    
    def add_model_by_url(self, url:str, ) -&gt; None:
        &#34;&#34;&#34;Add a model by URL.

        Args:
            url (str): ggUF URL
        &#34;&#34;&#34;
        model_data = ModelData(url, db_dir=self.gguf_db_dir)
        self.add_model_data(model_data)

    def add_model_by_json(self, json_file_path:str) -&gt; None:
        &#34;&#34;&#34;Add a model from a JSON file.

        Args:
            json_file_path (str): Path to ModelData JSON file
        &#34;&#34;&#34;
        model_data = ModelData.from_json(json_file_path)
        self.add_model_data(model_data)

    def save_all_models(self) -&gt; None:
        &#34;&#34;&#34;Save all ModelData objects to file.&#34;&#34;&#34;
        for model in self.models:
            model:ModelData = model
            model.save_json()
                
    @staticmethod
    def _model_links_from_repo(hf_repo_url:str):
        &#34;&#34;&#34;Extract ggUF model links from a HuggingFace repo page.

        Args:
            hf_repo_url (str): URL of HuggingFace model repo

        Returns:
            list: List of ggUF URLs
        &#34;&#34;&#34;
        #extract models from hf 
        response = requests.get(hf_repo_url)
        html = response.text
        soup = bs4.BeautifulSoup(html, &#39;html.parser&#39;)
        #find all links that end with .gguf
        print(f&#34;Looking for {hf_repo_url} gguf files...&#34;)
        model_links = []
        for link in soup.find_all(&#39;a&#39;):
            href = link.get(&#39;href&#39;)
            if href is not None and href.endswith(&#34;.gguf&#34;):
                print(f&#34;Found model: {href}&#34;)
                model_links.append(href)
        return model_links
    
    def load_models_data_from_repo(self, hf_repo_url:str, 
                        user_tags:Optional[list[str]]=None,
                        ai_tags:Optional[list[str]]=None,
                        system_tags:Optional[list[str]]=None,
                        keywords:Optional[list[str]]=None, 
                        description:Optional[str]=None):
        &#34;&#34;&#34;Load model data from a HuggingFace repo page.

        Args:
            hf_repo_url (str): URL of HuggingFace model repo
            user_tags (Optional[list[str]], optional): User tags to apply. Defaults to None.
            ai_tags (Optional[list[str]], optional): AI tags to apply. Defaults to None.
            system_tags (Optional[list[str]], optional): System tags to apply. Defaults to None.
            keywords (Optional[list[str]], optional): Keywords to apply. Defaults to None.
            description (Optional[str], optional): Description to apply. Defaults to None.

        Returns:
            list: List of loaded ModelData objects
        &#34;&#34;&#34;
        #create model data from hf repo
        model_links = ModelDB._model_links_from_repo(hf_repo_url)
        model_datas = []
        for model_link in model_links:
            model_data = ModelData(gguf_url=model_link, db_dir=self.gguf_db_dir, user_tags=user_tags, ai_tags=ai_tags, system_tags=system_tags, description=description, keywords=keywords)
            model_datas.append(model_data)
            model_data.save_json()
        self.models.extend(model_datas)
        return model_datas

    def import_models_from_repo(self, hf_repo_url:str,
                        user_tags:Optional[list[str]]=None,
                        ai_tags:Optional[list[str]]=None,
                        system_tags:Optional[list[str]]=None,
                        keywords:Optional[list[str]]=None, 
                        description:Optional[str]=None,
                        replace_existing:bool=False,
                        ):
        &#34;&#34;&#34;Import models from a HuggingFace repo page.

        Args:
            hf_repo_url (str): URL of HuggingFace model repo  
            user_tags (Optional[list[str]], optional): User tags to apply. Defaults to None.
            ai_tags (Optional[list[str]], optional): AI tags to apply. Defaults to None.
            system_tags (Optional[list[str]], optional): System tags to apply. Defaults to None.
            keywords (Optional[list[str]], optional): Keywords to apply. Defaults to None.
            description (Optional[str], optional): Description to apply. Defaults to None.
            replace_existing (bool, optional): Whether to overwrite existing files. Defaults to False.
        &#34;&#34;&#34;
        #create model data from hf repo
        model_links = ModelDB._model_links_from_repo(hf_repo_url)
        print(f&#34;Loaded {len(model_links)} models from {hf_repo_url}.&#34;)
        for model_link in model_links:
            model_data = ModelData(gguf_url=model_link, db_dir=self.gguf_db_dir, user_tags=user_tags, ai_tags=ai_tags, system_tags=system_tags, description=description, keywords=keywords)
            model_data.save_json(replace_existing=replace_existing)
        self.load_models()
    

    def import_verified_model(self, 
                              name_search:Optional[str]=None,
                              quantization_search:Optional[str]=None,
                              keywords_search:Optional[str]=None,
                              copy_gguf:bool=True) -&gt; None:
        &#34;&#34;&#34;Import a verified model from the verified model database with ready configurations into your selected db dir.
        Use this to selectively add models from the verified model database to your own database.
        Models inlcude official dolphin, mistral, mixtral, solar and zephyr models in all available quantizations. 
        Args:
            name_search (Optional[str], optional): Search query for name. Defaults to None.
            quantization_search (Optional[str], optional): Search query for quantization. Defaults to None.
            keywords_search (Optional[str], optional): Search query for keywords. Defaults to None.
        &#34;&#34;&#34;
        if self.gguf_db_dir == VERIFIED_MODELS_DB_DIR:
            print(&#34;Cannot import verified model to the default database directory. All models should be already available here.&#34;)
        else:
            vmdb = ModelDB()
            model = vmdb.find_model(name_search, quantization_search, keywords_search)
            if copy_gguf and model.is_downloaded():
                source_file = model.gguf_file_path
                target_file = model.gguf_file_path.replace(vmdb.gguf_db_dir, self.gguf_db_dir)
                print(f&#34;Copying {source_file} to {target_file}...&#34;)
                copy_large_file(source_file, target_file)

            model.set_save_dir(self.gguf_db_dir)
            model.save_json()
            self.load_models()

    def list_available_models(self) -&gt; list[str]:
        &#34;&#34;&#34;Get a list of available model names.

        Returns:
            list[str]: List of model names
        &#34;&#34;&#34;
        print(f&#34;Available models in {self.gguf_db_dir}:&#34;)
        models = []
        for model in self.models:
            model:ModelData = model
            if model.name not in models:
                models.append(model.name)
        return models
    
    def list_models_quantizations(self, model_name:str) -&gt; list[str]:
        &#34;&#34;&#34;Get list of quantizations for a model.

        Args:
            model_name (str): Name of model

        Returns:
            list[str]: List of quantizations
        &#34;&#34;&#34;
        quantizations = []
        for model in self.models:
            model:ModelData = model
            if model.name == model_name:
                quantizations.append(model.model_quantization)
        return quantizations

    def show_db_info(self) -&gt; None:
        &#34;&#34;&#34;Print summary information about the database.&#34;&#34;&#34;
        print(f&#34;ModelDB summary:&#34;)
        print(f&#34;ModelDB dir: {self.gguf_db_dir}&#34;)
        print(f&#34;Number of models: {len(self.models)}&#34;)
        print(f&#34;Available models:&#34;)
        models_info = {}
        for model in self.models:
            model:ModelData = model
            if model.name not in models_info.keys():
                models_info[model.name] = {}
                models_info[model.name][&#34;quantizations&#34;] = []
                models_info[model.name][&#34;description&#34;] = model.description
                models_info[model.name][&#34;keywords&#34;] = model.keywords
            if model.model_quantization not in models_info[model.name][&#34;quantizations&#34;]:
                models_info[model.name][&#34;quantizations&#34;].append(model.model_quantization)
        
        for model_name, models_info in models_info.items():
            print(f&#34;\t{model_name}:&#34;)
            print(f&#34;\t\tQuantizations: {models_info[&#39;quantizations&#39;]}&#34;)
            print(f&#34;\t\tKeywords: {models_info[&#39;keywords&#39;]}&#34;)
            print(f&#34;\t\tDescription: {models_info[&#39;description&#39;]}&#34;)
            print(f&#34;\t-------------------------------&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gguf_modeldb.db.ModelDB.add_model_by_json"><code class="name flex">
<span>def <span class="ident">add_model_by_json</span></span>(<span>self, json_file_path: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a model from a JSON file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>json_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to ModelData JSON file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_model_by_json(self, json_file_path:str) -&gt; None:
    &#34;&#34;&#34;Add a model from a JSON file.

    Args:
        json_file_path (str): Path to ModelData JSON file
    &#34;&#34;&#34;
    model_data = ModelData.from_json(json_file_path)
    self.add_model_data(model_data)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.add_model_by_url"><code class="name flex">
<span>def <span class="ident">add_model_by_url</span></span>(<span>self, url: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a model by URL.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>ggUF URL</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_model_by_url(self, url:str, ) -&gt; None:
    &#34;&#34;&#34;Add a model by URL.

    Args:
        url (str): ggUF URL
    &#34;&#34;&#34;
    model_data = ModelData(url, db_dir=self.gguf_db_dir)
    self.add_model_data(model_data)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.add_model_data"><code class="name flex">
<span>def <span class="ident">add_model_data</span></span>(<span>self, model_data: <a title="gguf_modeldb.model_data.ModelData" href="model_data.html#gguf_modeldb.model_data.ModelData">ModelData</a>, save_model=True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a ModelData object to the database.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_data</code></strong> :&ensp;<code>ModelData</code></dt>
<dd>ModelData object to add</dd>
<dt><strong><code>save_model</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to save ModelData to file. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_model_data(self, model_data:ModelData, save_model=True) -&gt; None:
    &#34;&#34;&#34;Add a ModelData object to the database.

    Args:
        model_data (ModelData): ModelData object to add
        save_model (bool, optional): Whether to save ModelData to file. Defaults to True.
    &#34;&#34;&#34;
    self.models.append(model_data)
    if save_model:
        model_data.save_json()</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.find_model"><code class="name flex">
<span>def <span class="ident">find_model</span></span>(<span>self, name_query: Optional[str] = None, quantization_query: Optional[str] = None, keywords_query: Optional[str] = None) ‑> Optional[<a title="gguf_modeldb.model_data.ModelData" href="model_data.html#gguf_modeldb.model_data.ModelData">ModelData</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Find top matching model based on queries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name_query</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Search query for name</dd>
<dt><strong><code>quantization_query</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Search query for quantization</dd>
<dt><strong><code>keywords_query</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Search query for keywords</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[ModelData]</code></dt>
<dd>Top matching ModelData object or None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_model(self, name_query:Optional[str]=None, 
               quantization_query:Optional[str]=None, 
               keywords_query:Optional[str]=None,
               ) -&gt; Optional[ModelData]:
    &#34;&#34;&#34;Find top matching model based on queries.

    Args:
        name_query (str, optional): Search query for name
        quantization_query (str, optional): Search query for quantization
        keywords_query (str, optional): Search query for keywords

    Returns:
        Optional[ModelData]: Top matching ModelData object or None
    &#34;&#34;&#34;
    sorted_models = self.find_models(name_query, quantization_query, keywords_query)
    if sorted_models is None or len(sorted_models) == 0:
        if len(self.models) == 0:
            print(f&#34;There were no models to be searched. Try importing a verified model or using the defualt db dir.&#34;)
        raise Exception(f&#34;Could not find a model matching the query: {name_query} {quantization_query} {keywords_query}&#34;)
    else:
        #print(f&#34;Found {len(sorted_models)} models.&#34;)
        #print(sorted_models)
        return sorted_models[0]</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.find_models"><code class="name flex">
<span>def <span class="ident">find_models</span></span>(<span>self, name_query: Optional[str] = None, quantization_query: Optional[str] = None, keywords_query: Optional[str] = None, treshold: float = 0.6) ‑> Optional[None]</span>
</code></dt>
<dd>
<div class="desc"><p>Search for models based on name, quantization, and keywords.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name_query</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Search query for name</dd>
<dt><strong><code>quantization_query</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Search query for quantization </dd>
<dt><strong><code>keywords_query</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Search query for keywords</dd>
<dt><strong><code>treshold</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Minimum score threshold. Defaults to 0.6.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[None, list]</code></dt>
<dd>Sorted list of models exceeding threshold,
or None if no query provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_models(self, name_query:Optional[str]=None, 
               quantization_query:Optional[str]=None, 
               keywords_query:Optional[str]=None,
               treshold:float=0.6) -&gt; Union[None, list]:
    &#34;&#34;&#34;Search for models based on name, quantization, and keywords.

    Args:
        name_query (str, optional): Search query for name
        quantization_query (str, optional): Search query for quantization 
        keywords_query (str, optional): Search query for keywords
        treshold (float, optional): Minimum score threshold. Defaults to 0.6.

    Returns:
        Union[None, list]: Sorted list of models exceeding threshold,
                           or None if no query provided
    &#34;&#34;&#34;
    if name_query is None and quantization_query is None and keywords_query is None:
        return None
    scoring_models_dict = {}
    for i, model in enumerate(self.models):
        scoring_models_dict[i] = {&#34;model&#34;:model, &#34;score&#34;:0}
    for id in scoring_models_dict.keys():
        model = scoring_models_dict[id][&#34;model&#34;]
        model:ModelData = model
        model_name = model.name
        model_quantization = model.model_quantization
        model_keywords = model.keywords
        if name_query is not None:
            #print(f&#34;Searching for name: {name_query}&#34;)
            top_name_score = 0
            for model_subname in model_name.split(&#34;-&#34;):
                name_score = compare_two_strings(name_query, model_subname)
                if name_score &gt; top_name_score:
                    top_name_score = name_score
            if top_name_score &gt; treshold:
                scoring_models_dict[id][&#34;score&#34;] += top_name_score*4
            #print(f&#34;Model {model_name} {model_quantization} top score: {top_name_score} treshold: {treshold}&#34;)
        if quantization_query is not None:
            #print(f&#34;Searching for quantization: {quantization_query}&#34;)
            quantization_score = compare_two_strings(quantization_query, model_quantization)
            if quantization_score &gt; treshold:
                scoring_models_dict[id][&#34;score&#34;] += quantization_score*2
            #print(f&#34;Model {model_name} {model_quantization} score: {quantization_score} treshold: {treshold}&#34;)
        if keywords_query is not None:
            #print(f&#34;Searching for keyword: {keywords_query}&#34;)
            best_keyword_score = 0
            for keyword in model_keywords:
                keyword_score = compare_two_strings(keywords_query, keyword)
                if keyword_score &gt; best_keyword_score:
                    best_keyword_score = keyword_score
            if best_keyword_score &gt; treshold:
                scoring_models_dict[id][&#34;score&#34;] += best_keyword_score
            #print(f&#34;Model {model_name} {model_quantization} score: {best_keyword_score} treshold: {treshold}&#34;)
        #print(f&#34;Model {model_name} {model_quantization} score: {scoring_models_dict[id][&#39;score&#39;]}&#34;)
    sorted_models = sorted(scoring_models_dict.items(), key=lambda x: x[1][&#34;score&#34;], reverse=True)
    #keep just the list of model data
    sorted_models = [x[1][&#34;model&#34;] for x in sorted_models]
    #print(f&#34;Found {len(sorted_models)} models.&#34;)
    #print(sorted_models)
    return sorted_models</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.get_model_by_url"><code class="name flex">
<span>def <span class="ident">get_model_by_url</span></span>(<span>self, url: str) ‑> Optional[<a title="gguf_modeldb.model_data.ModelData" href="model_data.html#gguf_modeldb.model_data.ModelData">ModelData</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get ModelData by exact URL match.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>ggUF URL</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[ModelData]</code></dt>
<dd>Matching ModelData or None if not found</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_by_url(self, url:str) -&gt; Optional[ModelData]:
    &#34;&#34;&#34;Get ModelData by exact URL match.

    Args:
        url (str): ggUF URL

    Returns:
        Optional[ModelData]: Matching ModelData or None if not found
    &#34;&#34;&#34;
    for model in self.models:
        model:ModelData = model
        if model.gguf_url == url:
            return model
    return None</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.import_models_from_repo"><code class="name flex">
<span>def <span class="ident">import_models_from_repo</span></span>(<span>self, hf_repo_url: str, user_tags: Optional[list[str]] = None, ai_tags: Optional[list[str]] = None, system_tags: Optional[list[str]] = None, keywords: Optional[list[str]] = None, description: Optional[str] = None, replace_existing: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Import models from a HuggingFace repo page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hf_repo_url</code></strong> :&ensp;<code>str</code></dt>
<dd>URL of HuggingFace model repo
</dd>
<dt><strong><code>user_tags</code></strong> :&ensp;<code>Optional[list[str]]</code>, optional</dt>
<dd>User tags to apply. Defaults to None.</dd>
<dt><strong><code>ai_tags</code></strong> :&ensp;<code>Optional[list[str]]</code>, optional</dt>
<dd>AI tags to apply. Defaults to None.</dd>
<dt><strong><code>system_tags</code></strong> :&ensp;<code>Optional[list[str]]</code>, optional</dt>
<dd>System tags to apply. Defaults to None.</dd>
<dt><strong><code>keywords</code></strong> :&ensp;<code>Optional[list[str]]</code>, optional</dt>
<dd>Keywords to apply. Defaults to None.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>Description to apply. Defaults to None.</dd>
<dt><strong><code>replace_existing</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to overwrite existing files. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_models_from_repo(self, hf_repo_url:str,
                    user_tags:Optional[list[str]]=None,
                    ai_tags:Optional[list[str]]=None,
                    system_tags:Optional[list[str]]=None,
                    keywords:Optional[list[str]]=None, 
                    description:Optional[str]=None,
                    replace_existing:bool=False,
                    ):
    &#34;&#34;&#34;Import models from a HuggingFace repo page.

    Args:
        hf_repo_url (str): URL of HuggingFace model repo  
        user_tags (Optional[list[str]], optional): User tags to apply. Defaults to None.
        ai_tags (Optional[list[str]], optional): AI tags to apply. Defaults to None.
        system_tags (Optional[list[str]], optional): System tags to apply. Defaults to None.
        keywords (Optional[list[str]], optional): Keywords to apply. Defaults to None.
        description (Optional[str], optional): Description to apply. Defaults to None.
        replace_existing (bool, optional): Whether to overwrite existing files. Defaults to False.
    &#34;&#34;&#34;
    #create model data from hf repo
    model_links = ModelDB._model_links_from_repo(hf_repo_url)
    print(f&#34;Loaded {len(model_links)} models from {hf_repo_url}.&#34;)
    for model_link in model_links:
        model_data = ModelData(gguf_url=model_link, db_dir=self.gguf_db_dir, user_tags=user_tags, ai_tags=ai_tags, system_tags=system_tags, description=description, keywords=keywords)
        model_data.save_json(replace_existing=replace_existing)
    self.load_models()</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.import_verified_model"><code class="name flex">
<span>def <span class="ident">import_verified_model</span></span>(<span>self, name_search: Optional[str] = None, quantization_search: Optional[str] = None, keywords_search: Optional[str] = None, copy_gguf: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Import a verified model from the verified model database with ready configurations into your selected db dir.
Use this to selectively add models from the verified model database to your own database.
Models inlcude official dolphin, mistral, mixtral, solar and zephyr models in all available quantizations. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name_search</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>Search query for name. Defaults to None.</dd>
<dt><strong><code>quantization_search</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>Search query for quantization. Defaults to None.</dd>
<dt><strong><code>keywords_search</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>Search query for keywords. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_verified_model(self, 
                          name_search:Optional[str]=None,
                          quantization_search:Optional[str]=None,
                          keywords_search:Optional[str]=None,
                          copy_gguf:bool=True) -&gt; None:
    &#34;&#34;&#34;Import a verified model from the verified model database with ready configurations into your selected db dir.
    Use this to selectively add models from the verified model database to your own database.
    Models inlcude official dolphin, mistral, mixtral, solar and zephyr models in all available quantizations. 
    Args:
        name_search (Optional[str], optional): Search query for name. Defaults to None.
        quantization_search (Optional[str], optional): Search query for quantization. Defaults to None.
        keywords_search (Optional[str], optional): Search query for keywords. Defaults to None.
    &#34;&#34;&#34;
    if self.gguf_db_dir == VERIFIED_MODELS_DB_DIR:
        print(&#34;Cannot import verified model to the default database directory. All models should be already available here.&#34;)
    else:
        vmdb = ModelDB()
        model = vmdb.find_model(name_search, quantization_search, keywords_search)
        if copy_gguf and model.is_downloaded():
            source_file = model.gguf_file_path
            target_file = model.gguf_file_path.replace(vmdb.gguf_db_dir, self.gguf_db_dir)
            print(f&#34;Copying {source_file} to {target_file}...&#34;)
            copy_large_file(source_file, target_file)

        model.set_save_dir(self.gguf_db_dir)
        model.save_json()
        self.load_models()</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.list_available_models"><code class="name flex">
<span>def <span class="ident">list_available_models</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of available model names.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>List of model names</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_available_models(self) -&gt; list[str]:
    &#34;&#34;&#34;Get a list of available model names.

    Returns:
        list[str]: List of model names
    &#34;&#34;&#34;
    print(f&#34;Available models in {self.gguf_db_dir}:&#34;)
    models = []
    for model in self.models:
        model:ModelData = model
        if model.name not in models:
            models.append(model.name)
    return models</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.list_models_quantizations"><code class="name flex">
<span>def <span class="ident">list_models_quantizations</span></span>(<span>self, model_name: str) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get list of quantizations for a model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of model</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>List of quantizations</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_models_quantizations(self, model_name:str) -&gt; list[str]:
    &#34;&#34;&#34;Get list of quantizations for a model.

    Args:
        model_name (str): Name of model

    Returns:
        list[str]: List of quantizations
    &#34;&#34;&#34;
    quantizations = []
    for model in self.models:
        model:ModelData = model
        if model.name == model_name:
            quantizations.append(model.model_quantization)
    return quantizations</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.load_models"><code class="name flex">
<span>def <span class="ident">load_models</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Load ModelData objects from the database directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_models(self) -&gt; None:
    &#34;&#34;&#34;Load ModelData objects from the database directory.&#34;&#34;&#34;
    self.models = []
    files = list_files_in_dir(self.gguf_db_dir, False, True, [&#34;.json&#34;], absolute=True)
    for file in files:
        try:
            model_data = ModelData.from_json(file)
            self.models.append(model_data)
        except Exception as e:
            print(f&#34;Error trying to load from {file}: \t\n{e}, \nskipping...&#34;)
            continue
    print(f&#34;Loaded {len(self.models)} models from {self.gguf_db_dir}.&#34;)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.load_models_data_from_repo"><code class="name flex">
<span>def <span class="ident">load_models_data_from_repo</span></span>(<span>self, hf_repo_url: str, user_tags: Optional[list[str]] = None, ai_tags: Optional[list[str]] = None, system_tags: Optional[list[str]] = None, keywords: Optional[list[str]] = None, description: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load model data from a HuggingFace repo page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hf_repo_url</code></strong> :&ensp;<code>str</code></dt>
<dd>URL of HuggingFace model repo</dd>
<dt><strong><code>user_tags</code></strong> :&ensp;<code>Optional[list[str]]</code>, optional</dt>
<dd>User tags to apply. Defaults to None.</dd>
<dt><strong><code>ai_tags</code></strong> :&ensp;<code>Optional[list[str]]</code>, optional</dt>
<dd>AI tags to apply. Defaults to None.</dd>
<dt><strong><code>system_tags</code></strong> :&ensp;<code>Optional[list[str]]</code>, optional</dt>
<dd>System tags to apply. Defaults to None.</dd>
<dt><strong><code>keywords</code></strong> :&ensp;<code>Optional[list[str]]</code>, optional</dt>
<dd>Keywords to apply. Defaults to None.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>Description to apply. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of loaded ModelData objects</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_models_data_from_repo(self, hf_repo_url:str, 
                    user_tags:Optional[list[str]]=None,
                    ai_tags:Optional[list[str]]=None,
                    system_tags:Optional[list[str]]=None,
                    keywords:Optional[list[str]]=None, 
                    description:Optional[str]=None):
    &#34;&#34;&#34;Load model data from a HuggingFace repo page.

    Args:
        hf_repo_url (str): URL of HuggingFace model repo
        user_tags (Optional[list[str]], optional): User tags to apply. Defaults to None.
        ai_tags (Optional[list[str]], optional): AI tags to apply. Defaults to None.
        system_tags (Optional[list[str]], optional): System tags to apply. Defaults to None.
        keywords (Optional[list[str]], optional): Keywords to apply. Defaults to None.
        description (Optional[str], optional): Description to apply. Defaults to None.

    Returns:
        list: List of loaded ModelData objects
    &#34;&#34;&#34;
    #create model data from hf repo
    model_links = ModelDB._model_links_from_repo(hf_repo_url)
    model_datas = []
    for model_link in model_links:
        model_data = ModelData(gguf_url=model_link, db_dir=self.gguf_db_dir, user_tags=user_tags, ai_tags=ai_tags, system_tags=system_tags, description=description, keywords=keywords)
        model_datas.append(model_data)
        model_data.save_json()
    self.models.extend(model_datas)
    return model_datas</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.save_all_models"><code class="name flex">
<span>def <span class="ident">save_all_models</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Save all ModelData objects to file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_all_models(self) -&gt; None:
    &#34;&#34;&#34;Save all ModelData objects to file.&#34;&#34;&#34;
    for model in self.models:
        model:ModelData = model
        model.save_json()</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.set_model_db_dir"><code class="name flex">
<span>def <span class="ident">set_model_db_dir</span></span>(<span>self, model_db_dir: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the database directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_db_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to database directory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_model_db_dir(self, model_db_dir:str) -&gt; None:
    &#34;&#34;&#34;Set the database directory.

    Args:
        model_db_dir (str): Path to database directory
    &#34;&#34;&#34;
    print(f&#34;ModelDB dir set to {model_db_dir}.&#34;)
    self.gguf_db_dir = create_dir(model_db_dir)</code></pre>
</details>
</dd>
<dt id="gguf_modeldb.db.ModelDB.show_db_info"><code class="name flex">
<span>def <span class="ident">show_db_info</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Print summary information about the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_db_info(self) -&gt; None:
    &#34;&#34;&#34;Print summary information about the database.&#34;&#34;&#34;
    print(f&#34;ModelDB summary:&#34;)
    print(f&#34;ModelDB dir: {self.gguf_db_dir}&#34;)
    print(f&#34;Number of models: {len(self.models)}&#34;)
    print(f&#34;Available models:&#34;)
    models_info = {}
    for model in self.models:
        model:ModelData = model
        if model.name not in models_info.keys():
            models_info[model.name] = {}
            models_info[model.name][&#34;quantizations&#34;] = []
            models_info[model.name][&#34;description&#34;] = model.description
            models_info[model.name][&#34;keywords&#34;] = model.keywords
        if model.model_quantization not in models_info[model.name][&#34;quantizations&#34;]:
            models_info[model.name][&#34;quantizations&#34;].append(model.model_quantization)
    
    for model_name, models_info in models_info.items():
        print(f&#34;\t{model_name}:&#34;)
        print(f&#34;\t\tQuantizations: {models_info[&#39;quantizations&#39;]}&#34;)
        print(f&#34;\t\tKeywords: {models_info[&#39;keywords&#39;]}&#34;)
        print(f&#34;\t\tDescription: {models_info[&#39;description&#39;]}&#34;)
        print(f&#34;\t-------------------------------&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gguf_modeldb" href="index.html">gguf_modeldb</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gguf_modeldb.db.ModelDB" href="#gguf_modeldb.db.ModelDB">ModelDB</a></code></h4>
<ul class="">
<li><code><a title="gguf_modeldb.db.ModelDB.add_model_by_json" href="#gguf_modeldb.db.ModelDB.add_model_by_json">add_model_by_json</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.add_model_by_url" href="#gguf_modeldb.db.ModelDB.add_model_by_url">add_model_by_url</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.add_model_data" href="#gguf_modeldb.db.ModelDB.add_model_data">add_model_data</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.find_model" href="#gguf_modeldb.db.ModelDB.find_model">find_model</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.find_models" href="#gguf_modeldb.db.ModelDB.find_models">find_models</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.get_model_by_url" href="#gguf_modeldb.db.ModelDB.get_model_by_url">get_model_by_url</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.import_models_from_repo" href="#gguf_modeldb.db.ModelDB.import_models_from_repo">import_models_from_repo</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.import_verified_model" href="#gguf_modeldb.db.ModelDB.import_verified_model">import_verified_model</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.list_available_models" href="#gguf_modeldb.db.ModelDB.list_available_models">list_available_models</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.list_models_quantizations" href="#gguf_modeldb.db.ModelDB.list_models_quantizations">list_models_quantizations</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.load_models" href="#gguf_modeldb.db.ModelDB.load_models">load_models</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.load_models_data_from_repo" href="#gguf_modeldb.db.ModelDB.load_models_data_from_repo">load_models_data_from_repo</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.save_all_models" href="#gguf_modeldb.db.ModelDB.save_all_models">save_all_models</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.set_model_db_dir" href="#gguf_modeldb.db.ModelDB.set_model_db_dir">set_model_db_dir</a></code></li>
<li><code><a title="gguf_modeldb.db.ModelDB.show_db_info" href="#gguf_modeldb.db.ModelDB.show_db_info">show_db_info</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>